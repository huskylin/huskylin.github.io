<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>工程師都是中二病</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huskylin.github.io/"/>
  <updated>2023-02-17T17:12:14.031Z</updated>
  <id>https://huskylin.github.io/</id>
  
  <author>
    <name>huskylin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用生活中的例子理解防抖與節流 Debounce &amp; Throttle in daily life</title>
    <link href="https://huskylin.github.io/2023/02/17/%E7%94%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3%E9%98%B2%E6%8A%96%E8%88%87%E7%AF%80%E6%B5%81-Debounce-Throttle-in-daily-life/"/>
    <id>https://huskylin.github.io/2023/02/17/%E7%94%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3%E9%98%B2%E6%8A%96%E8%88%87%E7%AF%80%E6%B5%81-Debounce-Throttle-in-daily-life/</id>
    <published>2023-02-17T09:49:56.000Z</published>
    <updated>2023-02-17T17:12:14.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用生活中的例子理解防抖與節流-Debounce-amp-Throttle-in-daily-life"><a href="#用生活中的例子理解防抖與節流-Debounce-amp-Throttle-in-daily-life" class="headerlink" title="用生活中的例子理解防抖與節流 Debounce &amp; Throttle in daily life"></a>用生活中的例子理解防抖與節流 Debounce &amp; Throttle in daily life</h1><p>關於 Debounce &amp; Throttle 正經詳細的教學已經不少<br>如果還是無法完全體會，那麼不妨換一個角度來理解看看<br>這篇文章會用搭公車與接電話來比喻兩者的運作邏輯<br>也許能加深印象!</p><h2 id="Debounce-amp-Throttle-是什麼功能"><a href="#Debounce-amp-Throttle-是什麼功能" class="headerlink" title="Debounce &amp; Throttle 是什麼功能"></a>Debounce &amp; Throttle 是什麼功能</h2><p>網頁中常常會有 <strong>監聽A事件 =&gt; 產生B動作</strong> 的情境</p><ul><li>監聽瀏覽器捲軸的滾動事件，並顯示動畫</li><li>監聽input內容，並產生自動補全</li></ul><p>如果沒有做 Debounce 或 Throttle<br>就會因為<strong>監聽到時時刻刻的變化，並產生動作而消耗大量效能</strong><br>例如: 只是滾動捲軸就可以產生數十到數百個事件 </p><iframe style="width: 100%; height: 300px;" scrolling="no" title="Scroll events counter" src="https://codepen.io/dcorb/embed/PZOZgB?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href="https://codepen.io/dcorb/pen/PZOZgB" target="_blank" rel="noopener">  Scroll events counter</a> by Corbacho (<a href="https://codepen.io/dcorb" target="_blank" rel="noopener">@dcorb</a>)  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</iframe><blockquote><p>《Debouncing and Throttling Explained Through Examples》by David Corbacho<br><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">https://css-tricks.com/debouncing-throttling-explained-examples/</a></p></blockquote><p>而實際應用中，我們<strong>不需要緊迫盯人</strong>，時時刻刻都在監看變化<br>不但浪費效能，甚至會給使用者”喂! 我還沒完成 幹嘛亂動”的感覺<br>例如: </p><ul><li>輸入框的自動自動補全，可以等到使用者打字停止後200毫秒後再顯示</li><li>每過200毫秒，再檢查一次捲軸滾動的位置是否要顯示動畫了</li></ul><p>所以 Debounce 與 Throttle 都是節省效能的作法</p><h2 id="Debounce-防抖實作與生活舉例"><a href="#Debounce-防抖實作與生活舉例" class="headerlink" title="Debounce 防抖實作與生活舉例"></a>Debounce 防抖實作與生活舉例</h2><p>Debounce 的實作，在生活中就好像在搭公車一樣<br><strong>公車停在站牌後，會等大家排隊上車<br>等到大家上車後，才一次出發</strong></p><ul><li>排隊上車的人 =&gt; 監聽的事件，如: 捲軸滾動、輸入框打字</li><li>公車出發 =&gt; 對應的事件，如: 顯示動畫、顯示自動補全</li></ul><p><img src="https://i.imgur.com/9J0hr0m.gif" alt=""></p><p>而程式碼的邏輯則是<br>接收到執行的指令時，會延遲一段時間才執行<br>如果這段時間內又被觸發，就重新倒數</p><pre><code class="js">// debounce 實作const debounce = (fn, delay) =&gt; {  let timeoutID = null;  return (...args) =&gt; {    clearTimeout(timeoutID);    timeoutID = setTimeout(() =&gt; {      fn(...args);    }, delay);  };};</code></pre><p>完整範例程式碼，可以動手玩玩:</p><iframe src="https://codesandbox.io/embed/debounce-bus-stop-cj7vj2?fontsize=14&hidenavigation=1&theme=dark"     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"     title="debounce-bus-stop"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h2 id="Throttle-節流實作與生活舉例"><a href="#Throttle-節流實作與生活舉例" class="headerlink" title="Throttle 節流實作與生活舉例"></a>Throttle 節流實作與生活舉例</h2><p>Debounce 的實作，在生活中就好像客服在接電話一樣<br><strong>有人打電話進來後，就會進入忙線狀態(假設每通電話時間固定)<br>忙線時，再有其他人打進來也不會理會</strong><br>直到時間結束才會接下一通處理</p><ul><li>打進來的人 =&gt; 監聽的事件，如: 捲軸滾動、輸入框打字</li><li>接通處理 =&gt; 對應的事件，如: 顯示動畫、顯示自動補全</li></ul><p><img src="https://i.imgur.com/x135Fgl.gif" alt=""></p><p>而程式碼的邏輯<br>除了接電話，撰文時也覺得其實很像遊戲放技能<br>接收到執行的指令時，會檢查是不是在忙線中、CD是不是還在冷卻<br>如果這段時間內又監聽到事件，就不會觸發後續動作，節省效能<br>直到冷卻完成才能再接下一通、才能再放技能</p><pre><code class="js">// throttle 實作const throttle = (fn, delay) =&gt; {  let timeoutID = null;  return (...args) =&gt; {    if (timeoutID) return;    timeoutID = setTimeout(() =&gt; {      fn(...args);      timeoutID = null;    }, delay);  };};</code></pre><p>完整範例程式碼，可以動手玩玩:</p><iframe src="https://codesandbox.io/embed/throttle-phone-call-u1o1bv?fontsize=14&hidenavigation=1&theme=dark"     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"     title="throttle-phone-call"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h2 id="註記與結語"><a href="#註記與結語" class="headerlink" title="註記與結語"></a>註記與結語</h2><p>本篇的範例是比較單純的 Debounce &amp; Throttle<br>也是為了方便初學的人學習<br>在 loadash, underscore 等函式庫中<br>提供了其他參數，可以應用更廣泛的情境<br>例如: leading 參數可以讓 Debounce 變成先執行動作後，才進入延遲CD<br>所以延遲與執行的先後，不能當作區別兩者的方式<br>兩者最大的區別</p><ul><li>Debounce 是把一連串的動作，變成只執行一次</li><li>Throttle 即使一連串動作超長，每隔一段緩衝時間，還是會執行一次</li></ul><p>了解了這兩種方式後，除了輸入框與捲動軸以外其他<br>例如:拖曳物件、需要消耗大量效能的畫面渲染(圖表、地圖的互動)<br>都可以考慮加入 Debounce &amp; Throttle 節省效能的設計<br>幫助你的網頁體驗與精緻度大幅提升!</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">Debouncing and Throttling Explained Through Examples</a></li><li><a href="https://www.explainthis.io/zh-hant/interview-guides/javascript-whiteboard/debounce" target="_blank" rel="noopener">手寫防抖 (debounce) 函式</a></li><li><a href="https://www.explainthis.io/zh-hant/interview-guides/javascript-whiteboard/throttle" target="_blank" rel="noopener">手寫節流 (throttle) 函式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用生活中的例子理解防抖與節流-Debounce-amp-Throttle-in-daily-life&quot;&gt;&lt;a href=&quot;#用生活中的例子理解防抖與節流-Debounce-amp-Throttle-in-daily-life&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>React 面試常見觀念系列 - Virtual DOM, Reconciliation</title>
    <link href="https://huskylin.github.io/2022/10/24/React%20%E9%9D%A2%E8%A9%A6%E5%B8%B8%E8%A6%8B%E8%A7%80%E5%BF%B5%E7%B3%BB%E5%88%97%20-%20Virtual%20DOM,%20Reconciliation/"/>
    <id>https://huskylin.github.io/2022/10/24/React%20%E9%9D%A2%E8%A9%A6%E5%B8%B8%E8%A6%8B%E8%A7%80%E5%BF%B5%E7%B3%BB%E5%88%97%20-%20Virtual%20DOM,%20Reconciliation/</id>
    <published>2022-10-24T12:47:47.000Z</published>
    <updated>2023-02-20T12:52:06.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-面試常見觀念系列-Virtual-DOM-Reconciliation"><a href="#React-面試常見觀念系列-Virtual-DOM-Reconciliation" class="headerlink" title="React 面試常見觀念系列 - Virtual DOM, Reconciliation"></a>React 面試常見觀念系列 - Virtual DOM, Reconciliation</h1><h2 id="在-React-中，什麼是-Virtual-DOM"><a href="#在-React-中，什麼是-Virtual-DOM" class="headerlink" title="在 React 中，什麼是 Virtual DOM?"></a>在 React 中，什麼是 Virtual DOM?</h2><p>在網頁世界中，DOM 是一個用樹狀結構表達網頁文件的模型<br>也是我們可以在瀏覽器中開發者工具中可以看到的實際結構<br>例如:這樣的網頁<br><img src="https://i.imgur.com/dhSy6ZB.png" alt=""><br>我們用 HTML 來表達 DOM 可以等同於</p><pre><code class="HTML">&lt;div id=&quot;header&quot;&gt;  &lt;h1 class=&quot;title&quot;&gt;React&lt;/h1&gt;  &lt;p class=&quot;content&quot;&gt;A JavaScript library for building user&lt;/p&gt;&lt;/div&gt;</code></pre><p>而虛擬 DOM 則是，用 JavaScript 物件的形式，來儲存這樣的結構(實際上更加複雜)</p><pre><code class="javascript">{    tag: &quot;div&quot;,    props: {        id: &quot;header&quot;    },    children: [        {            tag: &quot;h1&quot;,            props: { className: &quot;title&quot; },            children: [&quot;React&quot;]        },        {            tag: &quot;p&quot;,            props: { className: &quot;content&quot; },            children: [&quot;A JavaScript library for building user&quot;]        }    ]}</code></pre><h2 id="那麼為什麼要使用-Virtual-DOM-呢"><a href="#那麼為什麼要使用-Virtual-DOM-呢" class="headerlink" title="那麼為什麼要使用 Virtual DOM 呢?"></a>那麼為什麼要使用 Virtual DOM 呢?</h2><p><strong>1. 操作成本與效能</strong><br>操作真實 DOM 的成本可能是巨大的<br>即使畫面只有一小部分需要更新，卻需要重新繪製一整個 DOM<br>就如同在麥當勞點了全餐，但是你發現店員把可樂給成了紅茶<br>店員說「不好意思，我們馬上為您把餐點重做」<br>結果馬上轉身把漢堡跟薯條也都丟掉了<br>你一定會心想「WTF ? 不是重新給一杯飲料就好嗎?」</p><p>尤其在現代網頁中，網頁往往是結構龐大且畫面更新頻繁<br>勢必會有效能低下的問題<br>所以當畫面更新時，React 會建立新的 Virtual DOM tree 跟舊的 tree 進行比較<br>只更新有改變的部分。</p><p><strong>2. 擴展性</strong></p><ul><li>由於 Virtual DOM 其實就是 JS 物件，可以用 JS 的方法來操作 DOM</li><li>Virtual DOM 不只可以轉化成網頁，也可以轉化成 Android 或是 iOS 的介面<br>  所以對開發者角度來說是更有跨平台擴展性的，例如: React Native</li><li>不直接操作 DOM，可以降低被 XSS 攻擊的風險</li></ul><h2 id="那麼它是怎麼更新-Virtual-DOM-tree-的呢"><a href="#那麼它是怎麼更新-Virtual-DOM-tree-的呢" class="headerlink" title="那麼它是怎麼更新 Virtual DOM tree 的呢?"></a>那麼它是怎麼更新 Virtual DOM tree 的呢?</h2><p>如果直接比較新舊兩棵樹，那麼就必須一個一個節點走訪比對，會消耗大量效能<br>所以 React 使用 Diffing 演算法來找出差異，進行更新(替換、刪除、移動、修改)<br>邏輯如下:</p><p><strong>1. 檢查節點類型</strong></p><ul><li>如果新舊類型不同 =&gt; 直接放棄原有的子樹，直接重建，省去後面走訪與比較所浪費的效能</li><li>如果新舊類型相同 =&gt; 保留原有子樹，只更新有差異的屬性</li></ul><p>例如: 把一開始的<code>&lt;div&gt;</code>元素改成<code>&lt;section&gt;</code>或其他元素<br>那麼 React 會卸載原本的<code>&lt;div&gt;</code>以及裡面的子樹<br>包含<code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>都會被銷毀並重建</p><pre><code class="HTML">// 原本的&lt;div id=&quot;header&quot;&gt;  &lt;h1&gt;...&lt;/h1&gt;   &lt;p class=&quot;content&quot;&gt;A JavaScript library for building user&lt;/p&gt;&lt;/div&gt;// 新的&lt;section id=&quot;header&quot;&gt;  &lt;h1&gt;...&lt;/h1&gt;   &lt;p class=&quot;content&quot;&gt;A JavaScript library for building user&lt;/p&gt;&lt;/section&gt;</code></pre><p>如果是同類型，則只會比對、更新有改變的屬性</p><pre><code class="HTML">// 原本的&lt;div id=&quot;header&quot;&gt;  &lt;h1&gt;...&lt;/h1&gt;   &lt;p class=&quot;content&quot;&gt;...&lt;/p&gt;&lt;/div&gt;// 新的&lt;section id=&quot;header&quot;&gt;  &lt;h1&gt;...&lt;/h1&gt;   &lt;p class=&quot;newContent&quot;&gt;...&lt;/p&gt;&lt;/section&gt;</code></pre><p><strong>2. 在遍歷 DOM 節點的子元素時</strong></p><ul><li>沒有 key 屬性 =&gt; React 可能會分不出來到底是部分修改還是全部更新，而造成效能浪費</li><li>擁有 key 屬性 =&gt; React 會用 key 來作為識別，而不會直接全部更新</li></ul><p>key 的部分可以獨立出一篇，就不深入解釋</p><h2 id="所以-Virtual-DOM-就是無敵的了"><a href="#所以-Virtual-DOM-就是無敵的了" class="headerlink" title="所以 Virtual DOM 就是無敵的了?"></a>所以 Virtual DOM 就是無敵的了?</h2><p><strong>Diffing 算法也是需要成本的!</strong><br>當遍歷樹節點、並且一一比較的過程，過於複雜<br>那麼就有可能出現，不進行比較，直接重新建立DOM還比較划算的情況<br>所以在設計上，官方也提醒我們</p><ol><li>如果頁面常常在兩種不同類型的元件或元素間切換，但其實內容是差不多的，那建議可以改成同類型的</li><li>如果是大型的列表，要設計合理、穩定的key，才能把效能最佳化</li></ol><p>更多資料可以參考官方文件<br><a href="https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm" target="_blank" rel="noopener">https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-面試常見觀念系列-Virtual-DOM-Reconciliation&quot;&gt;&lt;a href=&quot;#React-面試常見觀念系列-Virtual-DOM-Reconciliation&quot; class=&quot;headerlink&quot; title=&quot;React 面試常見
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>好香的框架! NestJS Zero to Hero 線上課程學習筆記</title>
    <link href="https://huskylin.github.io/2021/06/17/%E5%A5%BD%E9%A6%99%E7%9A%84%E6%A1%86%E6%9E%B6-NestJS-Zero-to-Hero-%E7%B7%9A%E4%B8%8A%E8%AA%B2%E7%A8%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"/>
    <id>https://huskylin.github.io/2021/06/17/%E5%A5%BD%E9%A6%99%E7%9A%84%E6%A1%86%E6%9E%B6-NestJS-Zero-to-Hero-%E7%B7%9A%E4%B8%8A%E8%AA%B2%E7%A8%8B%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/</id>
    <published>2021-06-17T12:53:34.000Z</published>
    <updated>2023-02-20T12:52:48.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好香的框架-NestJS-Zero-to-Hero-線上課程學習筆記"><a href="#好香的框架-NestJS-Zero-to-Hero-線上課程學習筆記" class="headerlink" title="好香的框架! NestJS Zero to Hero 線上課程學習筆記"></a>好香的框架! NestJS Zero to Hero 線上課程學習筆記</h1><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p><img src="https://i.imgur.com/dQgQa7f.png" alt=""></p><p>Nest.js 是一個架構、語法都與 Angular 非常相像的後端框架<br>使用 TypeScript 為開發語言<br>也是以 Express 框架為底層的 Node.js 框架 (我框架你的框架 !?!?!)<br>在不認識它之前<br>可以用 <code>Angular 版的 Node.js</code> 或是 <code>TypeScript 版的 Express</code> 來想像</p><p>日前剛好看到社團有人分享 Udemy 上的 Nest.js 課程限時免費中<br><a href="https://softnshare.com/nestjs-zero-to-hero/" target="_blank" rel="noopener">https://softnshare.com/nestjs-zero-to-hero/</a><br>之前就對這個框架很有興趣，趁著有免費的優質課程，就花了兩三天看完了<br>在學的過程中，我是覺得非常興奮的，因為它真的跟 Angular 太像了<br>對於已經會 NG 的開發者，我強烈推薦大家可以試試看 Nest.js ，非常好上手<br>甚至本來就也會用 Node.js ，那真的幾乎沒什麼學習成本<br>又可以享受新框架的種種優點</p><blockquote><h3 id="Nestjs-Framework幾個特點"><a href="#Nestjs-Framework幾個特點" class="headerlink" title="Nestjs Framework幾個特點:"></a>Nestjs Framework幾個特點:</h3><ul><li>Base On Express 框架和 socket.io 套件。</li><li>語法風格類似 Angular，也有人覺得類似 Java Spring ，使用了許多裝飾器語法。</li><li>依賴注入( Dependency Injection )， Nestjs 大量使用依賴注入，建議使用此作法。</li><li>Exception layer ，可以做更多的 exception 處理。</li><li>Guards 作為路由警衛，處理訪問權限。</li><li>Interceptors 攔截器機制。</li><li>Unit Test &amp; E2E Test。</li></ul></blockquote><p>想要看更多關於 Nest.js 的簡介<br>可以去看這篇 <a href="[https://](https://ithelp.ithome.com.tw/articles/10190659)">Nestjs framework 30天初探:Day01 攻略行前說明 </a></p><p>本文主要是針對線上課程 <a href="https://www.udemy.com/course/nestjs-zero-to-hero/" target="_blank" rel="noopener">NestJS Zero to Hero - Modern TypeScript Back-end Development</a><br>所作的筆記內容<br>記錄一些觀念性的東西，實作部分可以到原線上課程學習<br>截至目前有近十萬名學生，評價也有 4.7 顆星，平時售價也平易近人<br>可以參考看看</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul><li>每個應用至少有一個模組，也就是根模組 (root module)</li><li>模組化是很有效組織元件的方式</li><li>每個模組放在自己獨立的資料夾是一個好習慣</li><li>模組是一種單例模式 (singleton) 的實踐，因而能夠匯出、匯入多個其他模組</li><li>定義一個模組使用裝飾器<code>@Module</code>來標記</li><li><code>@Module</code>擁有的屬性:<ul><li>providers: 依賴注入，註冊服務提供者</li><li>controllers: 實例化 controllers</li><li>exports: 匯出其他 modules</li><li>imports: 匯入其他 modules</li></ul></li><li>例如下面的結構可以用這樣的程式碼表示:<ul><li><img src="https://i.imgur.com/qo6mNTg.png" alt=""></li><li><img src="https://i.imgur.com/GkK97Hp.png" alt=""></li></ul></li></ul><h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><ul><li>處理請求 (requests) ，並且回應 (response)</li><li>是一個特定的路徑 (例如: <code>/tasks</code> 處理 task 的資源)</li><li>包含 handlers，處理 endpoints 以及 request methods (GET, POST, DELETE…)</li><li>受益於依賴注入 (dependency injection) ，在同一個模組中consume providers within the same module</li><li>定義一個模組使用裝飾器<code>@Controller</code>來標記<ul><li><code>@Controller</code> 接收字串型別的參數，用來表示要處理的路徑</li><li>例如: @Controller(‘tasks’)</li></ul></li></ul><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><ul><li>Handler 是 controller 內的方法 (method)</li><li>支援使用這類型裝飾器<ul><li>@Get()</li><li>@Post()</li><li>@Delete()</li><li>…</li></ul></li><li>處理流程為: <ol><li>接收到 HTTP 請求 (request)</li><li>請求經由路由 (route) 到 controller，接著呼叫並且傳入參數給 handler </li><li>handler 開始處理請求，例如: 從資料庫取得資料、運算…等等</li><li>handler 回傳結果，回傳結果可以是任何型別，包括<code>例外</code> (exception)， Nest.JS 會幫我們包裝處理給客戶端</li></ol></li></ul><h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><ul><li>如果有標記為<code>@Injectable</code>，就可以被注入</li><li>可以是純值、類別、同步/非同步的設計</li><li>providers 提供給 module 使用</li><li>可以被模組匯出，再讓其他模組做匯入、引入</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><ul><li>Service 是一種 providers ，但不是所有 providers 都屬於 services</li><li>是軟體開發中一種通用的概念，不只用於 NestJS, JavaScirpt 或後端開發</li><li>當被 <code>@Injectable()</code> 包起來提供給其他模組時，是一種單例模式(singleton)，意指相同的實例 (instance) 會在應用程式中被不同的地方使用</li><li>是主要的商業邏輯來源，例如: controller 會呼叫 service 來驗證資料、對資料庫新增資料、回傳結果</li><li><img src="https://i.imgur.com/ADX3MjG.png" alt=""></li></ul><h2 id="NestJS-的依賴注入"><a href="#NestJS-的依賴注入" class="headerlink" title="NestJS 的依賴注入"></a>NestJS 的依賴注入</h2><ul><li>任何一個元件都可以注入 provider ，只要它有被標記為可被注入的話 (<code>@Injectable</code>)</li><li>我們會在元件的 class 的建構子 (constructor) 裡面定義，Nest.JS 會幫我們處理、注入，使得它變成 class 內的一種屬性 (property)，供我們使用。</li><li><img src="https://i.imgur.com/ivLlQWP.png" alt=""></li></ul><h3 id="DTOs"><a href="#DTOs" class="headerlink" title="DTOs"></a>DTOs</h3><ul><li>Data Transfer Objects</li><li>是軟體開發的通用概念</li><li>幫助寫出更穩固的程式碼，而且可以用在 TypeScript 中</li><li>DTO 沒有行為，除了 儲存、檢索 (retrieval) 、序列化、反序列化自己的資料</li><li>增加效能 (在小程式中微乎其微)</li><li>對資料驗證很有用</li><li>DTO 不是一個 model 定義，他是定義特定情況的資料形狀，例如: 建立一個工作項目</li><li>可以用 interface 或 class 定義，但是建議用 class ，並且建立清楚的文件</li><li>原因是因為 interface 是屬於 TypseScript 的，所以在執行階段就不會被保留了。 class 則屬於 JavaScript，會在執行階段被保留。</li><li>NestJS 在執行階段沒辦法參照 interface ，但可以參照到 class</li><li>範例: <img src="https://i.imgur.com/I0X9SHV.png" alt=""></li><li>DTO 可以用在很多地方controllers, services, pipes，在驗證資料時也很實用</li><li>DTO 不是強制的，就算不用也可以正常開發，但它可以使你更好維護與日後重構</li></ul><h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><ul><li><p>route handler 會先處理引數 (arguments) 上的 pipes 運算元，之後才呼叫 handler</p></li><li><p>可以用來做資料轉換或是資料驗證</p></li><li><p>可以回傳資料給 route handler ，不論是原始資料或是處理過的資料</p></li><li><p>可以丟出例外處理 (throw exceptions) ，被丟出的例外會由 NestJS 處理並且解析為一個錯誤的回應 (error response)</p></li><li><p>可以是非同步的</p></li><li><p>NestJS 裡有一些預設的 Pipes 在 <code>@nestjs/common</code> module 裡面，<br>  例如:</p><ul><li>ValidationPipe 驗證物件是否符合 DTOs</li><li>ParseIntPipe 引數預設型別是 string ，可以轉換成整數</li></ul></li><li><p>自訂義 Pipe 時的實作:</p><ul><li>是一個具有<code>@Injectable()</code>標記的 class</li><li>必須實踐<code>PipeTransform</code>，並包含 transform() 方法，用來給 NestJS 呼叫</li><li>transform() 接受兩個參數:<ul><li>value: 引數的值</li><li>metadata (optional): 轉換處理中可能用到的標記</li></ul></li><li>不論 transform() 回傳什麼值，都會傳到 route handler。例外處理將會傳給客戶端</li><li>可以被很多不同的方式消費 (consume)</li></ul></li><li><p>handler-level pipes<br>  <img src="https://i.imgur.com/vAtrWId.png" alt=""><br>  所有參數都會經過 pipe 處理</p></li><li><p>parameter-level pipes<br>  <img src="https://i.imgur.com/QpH9lHd.png" alt=""><br>  只有特定的參數會被 pipe 處理</p></li><li><p>global pipes<br>  <img src="https://i.imgur.com/x7zuzQM.png" alt=""><br>  應用層的 pipe 會套用在所有請求上</p></li><li><p>流程: <img src="https://i.imgur.com/wQL8Gc9.png" alt=""></p></li><li><p><a href="https://github.com/typestack/class-validator" target="_blank" rel="noopener">class-validator</a> 提供很多檢查 class 的驗證檢查</p></li></ul><h2 id="裝飾器語法"><a href="#裝飾器語法" class="headerlink" title="裝飾器語法"></a>裝飾器語法</h2><ul><li>@Get()</li><li>@Get(‘/:id’)</li><li>@Post()</li><li>@Patch(‘/:id/propertie’)</li><li>@Query()</li><li>@Body()</li><li>@Body(‘key’)</li><li>@Param(‘id’)</li></ul><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><ul><li><p>優點:</p><ul><li>將資料模型 (data model) 寫在同一個地方，易於維護、減少重工</li><li>很多工項可以自動化: 資料庫處理、資料型別、資料關聯</li><li>不用寫 SQL 原生語法(易學難精)，用你原本擅長的語言來寫</li><li>資料庫的抽象化，日後想要換資料庫時，比較方便</li><li>可以借用很多 OOP 的優點，例如: 繼承 (inheritance) 的架構很好被實踐</li></ul></li><li><p>缺點</p><ul><li>需要學習 ORM 的函式庫，不一定很容易</li><li>效能還行，但容易被忽視</li><li>容易忘記語法背後到底實際做了些什麼事情，可能造成一些維護上的問題</li></ul></li><li><p>TypeORM 是用在 Node.js 的 ORM 函式庫，並且支援 TypeScript</p></li><li><p>兩種常見的 ORM 模式:</p><ul><li>Active Record</li><li>Data Mapper</li><li><a href="https://orkhan.gitbook.io/typeorm/docs/active-record-data-mapper" target="_blank" rel="noopener">https://orkhan.gitbook.io/typeorm/docs/active-record-data-mapper</a></li></ul></li></ul><h2 id="Auth"><a href="#Auth" class="headerlink" title="Auth"></a>Auth</h2><ul><li>透過 Validation 設定密碼規則 (例如: 包含大小寫、特殊字元、長度)</li><li>可以用 <a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="noopener">Bcrypt</a> 套件來處理密碼加密的問題</li><li>雜湊 (hash) 函式可以使密碼被<strong>單向</strong>的加密</li><li>透過加上 salt 來避免暴力破解、彩虹表攻擊</li><li>介紹 JWT <ul><li>JWT 可以被所有人解碼，所以不應該存放機敏資料，例如: 密碼</li><li>適合用來做前端頁面的功能判斷，例如: 使用者有沒有權限看到這個按鈕</li><li>JWT 的存活期限該該要設置成很短暫</li></ul></li><li>用 裝飾器 @UseGuards，來做路由守衛</li><li>用 裝飾器 @UseInterceptors()，來做請求攔截、加工</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;好香的框架-NestJS-Zero-to-Hero-線上課程學習筆記&quot;&gt;&lt;a href=&quot;#好香的框架-NestJS-Zero-to-Hero-線上課程學習筆記&quot; class=&quot;headerlink&quot; title=&quot;好香的框架! NestJS Zero to He
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>利用Angular動態元件，製作高彈性客製化頁面! (下)</title>
    <link href="https://huskylin.github.io/2021/02/19/%E5%88%A9%E7%94%A8Angular%E5%8B%95%E6%85%8B%E5%85%83%E4%BB%B6%EF%BC%8C%E8%A3%BD%E4%BD%9C%E9%AB%98%E5%BD%88%E6%80%A7%E5%AE%A2%E8%A3%BD%E5%8C%96%E9%A0%81%E9%9D%A2-%E4%B8%8B/"/>
    <id>https://huskylin.github.io/2021/02/19/%E5%88%A9%E7%94%A8Angular%E5%8B%95%E6%85%8B%E5%85%83%E4%BB%B6%EF%BC%8C%E8%A3%BD%E4%BD%9C%E9%AB%98%E5%BD%88%E6%80%A7%E5%AE%A2%E8%A3%BD%E5%8C%96%E9%A0%81%E9%9D%A2-%E4%B8%8B/</id>
    <published>2021-02-19T12:49:50.000Z</published>
    <updated>2021-02-19T12:57:39.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用-Angular-動態元件，製作高彈性客製化頁面-下"><a href="#利用-Angular-動態元件，製作高彈性客製化頁面-下" class="headerlink" title="利用 Angular 動態元件，製作高彈性客製化頁面! (下)"></a>利用 Angular 動態元件，製作高彈性客製化頁面! (下)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接續上一篇<a href="https://huskylin.github.io/2021/02/18/利用Angular動態元件，製作高彈性客製化頁面-上/">利用Angular動態元件，製作高彈性客製化頁面! (上)</a><br>我們完成了 在頁面上自由動態產生 component 的功能<br>這一篇則會接下去帶大家完成</p><ul><li>刪除已經產生出的元件</li><li>在創立 component 時，傳入 Input 資料</li></ul><p>讓我們的功能更完整，更貼近實戰使用!</p><p>核心知識會用到: <a href="https://angular.io/api/core/ComponentRef" target="_blank" rel="noopener">ComponentRef</a></p><p>成果如下<br><img src="https://i.imgur.com/qTYij41.gif" alt=""><br><a href="https://huskylin.github.io/dynamic-component-demo-2/">https://huskylin.github.io/dynamic-component-demo-2/</a></p><hr><h2 id="刪除已經產生出的元件"><a href="#刪除已經產生出的元件" class="headerlink" title="刪除已經產生出的元件"></a>刪除已經產生出的元件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>要刪除動態產生的元件，首先我們得知道頁面上的眾多元件中<br>我們如何找出要刪除的那一個?<br>概念是這樣</p><ol><li>動態創立元件時，給予一個唯一值，記錄在該元件內</li><li>我們對元件按下刪除件的時候，利用 Output ，發送出該元件的唯一值</li><li>獲得唯一值後，在對應的 ComponentRef 中，利用 destroy 方法移除元件</li></ol><hr><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><h4 id="第一步，動態創立元件時，給予一個唯一值，記錄在該元件內"><a href="#第一步，動態創立元件時，給予一個唯一值，記錄在該元件內" class="headerlink" title="第一步，動態創立元件時，給予一個唯一值，記錄在該元件內"></a>第一步，動態創立元件時，給予一個唯一值，記錄在該元件內</h4><p>custom.component.ts</p><pre><code class="TypeScript">createComponent(component) {      ...      // 記錄 component 唯一值      wrapperRef.instance[&#39;uniqueKey&#39;] = ++this.childUniqueKey;      // 儲存 wrapper 跟 target 的 ref，之後更新資料、刪除元件時會用      this.customService.pushWrapperRefs(wrapperRef);      this.customService.pushChartRefs(targetRef);      // 如果開著刪除模式，新增的元件也要開啟刪除模式      this.customService.refreshRemoveMode(this.removeable);      // 訂閱刪除事件      const self = this;      wrapperRef.instance[&#39;remove&#39;].subscribe(componentIdx =&gt; {        self.customService.removeComponent(componentIdx);      });}</code></pre><p>解說:</p><ol><li><p>這邊的 wrapperRef.instance[‘uniqueKey’]<br> 會在該元件內創建一個名為uniqueKey的屬性 並且儲存傳進去的值<br> 就跟平時在寫 component 時<br> 寫</p><pre><code class="TypeScript"> export class MyComponent {     ...     uniqueKey = 123 }</code></pre><p> 是一樣的意思</p></li><li><p>customService.pushWrapperRefs、customService.pushChartRefs<br> 則是將 <a href="https://angular.io/api/core/ComponentRef" target="_blank" rel="noopener">ComponentRef</a> 儲存到 service 的陣列中，方便日後做刪除的操作</p></li><li><p>訂閱刪除事件<br> 別忘了訂閱元件的 EventEmitter ，這樣按下元件刪除鍵時才會收到動作</p></li></ol><hr><h4 id="第二步，我們對元件按下刪除件的時候，利用-Output-，發送出該元件的唯一值"><a href="#第二步，我們對元件按下刪除件的時候，利用-Output-，發送出該元件的唯一值" class="headerlink" title="第二步，我們對元件按下刪除件的時候，利用 Output ，發送出該元件的唯一值"></a>第二步，我們對元件按下刪除件的時候，利用 Output ，發送出該元件的唯一值</h4><p>small.component.ts</p><pre><code class="TypeScript">@Input() uniqueKey: number;@Output() remove: EventEmitter&lt;number&gt; = new EventEmitter();removeComponent() {    this.remove.emit(this.uniqueKey);  }</code></pre><hr><h4 id="第三步，獲得唯一值後，在對應的-ComponentRef-中，利用-destroy-方法移除元件"><a href="#第三步，獲得唯一值後，在對應的-ComponentRef-中，利用-destroy-方法移除元件" class="headerlink" title="第三步，獲得唯一值後，在對應的 ComponentRef 中，利用 destroy 方法移除元件"></a>第三步，獲得唯一值後，在對應的 ComponentRef 中，利用 destroy 方法移除元件</h4><p>custom.service.ts</p><pre><code class="TypeScript">removeComponent(uniqueKey) {    const idx = this.wrapperRefs.findIndex(e =&gt; e.instance.uniqueKey === uniqueKey)    this.wrapperRefs[idx].destroy();    this.wrapperRefs = this.wrapperRefs.filter(e =&gt; e.instance.uniqueKey !== uniqueKey);  }</code></pre><p>Angular 的 ComponentRef 提供了一個 destroy 的方法</p><blockquote><p>Destroys the component instance and all of the data structures associated with it.</p></blockquote><p>wrapperRefs 是一個儲存了我們所創立的元件的陣列<br>根據唯一值找出我們需要刪除的元件，並且呼叫 destroy 方法<br>就完成刪除的功能了~</p><hr><h2 id="在創立-component-時，傳入-Input-資料"><a href="#在創立-component-時，傳入-Input-資料" class="headerlink" title="在創立 component 時，傳入 Input 資料"></a>在創立 component 時，傳入 Input 資料</h2><p>我們的元件，通常也會需要傳入參數<br>畢竟元件通常是把功能抽出來<br>再把不同資料傳入後呈現不同的畫面</p><p>那動態產生元件時要怎麼傳入資料呢<br>答案也是使用 <code>ComponentRef.instance</code><br>程式碼如下:</p><pre><code class="TypeScript">updateInputData(component, targetRef) {    // 產生 InputData    const inputData = this.utilsService.getData(component.name, year);    // 傳入到 Input 中，會觸發在 ngOnInit    targetRef.instance[&#39;data&#39;] = inputData;    // 產生 change    const changes = {      data: new SimpleChange(undefined, inputData, false)    };    // 傳入到 Onchange    if (typeof targetRef.instance.ngOnChanges !== &#39;undefined&#39;) {      targetRef.instance.ngOnChanges(changes);    }}</code></pre><p>解說:</p><ol><li>targetRef.instance[‘data’] = inputData;<br> 會傳值到元件的 <code>@Input() data</code> 中<br> 注意這邊會觸發的生命週期是 OnInit 階段</li><li>如果想要觸發 OnChanges，就可以看後半段的程式碼<br> 先產生一個 change ，再透過 targetRef.instance.ngOnChanges(changes) 來觸發</li></ol><p>這樣就完成資料的傳值功能了~</p><hr><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><h3 id="刪除元件"><a href="#刪除元件" class="headerlink" title="刪除元件"></a>刪除元件</h3><p>開啟刪除模式後<br>這邊用了個類似手機APP移除的視覺效果<br>(UX方面，滑鼠移上去的時候再停止動畫，避免抖到點不到XD)<br>並且透過不同的 class name 達成不同的抖動延時<br>點擊按鈕後就會觸發 EventEmitter ，並且透過 ComponentRef.destroy() 刪除<br><img src="https://i.imgur.com/nUmP4RN.gif" alt=""></p><h3 id="透過動態元件呈現交叉分析"><a href="#透過動態元件呈現交叉分析" class="headerlink" title="透過動態元件呈現交叉分析"></a>透過動態元件呈現交叉分析</h3><p>這次我們在每個圖塊多加上了自己的時間篩選<br>以呈現動態元件的優點:<br><strong>使用者可以高度客製化希望看到的頁面</strong><br>另外在創立元件的選單上方，也加入了年份選擇<br>以呈現同樣的元件可以透過不同的 Input 資料<br>畫出不同的圖表內容<br><img src="https://i.imgur.com/ZXY3YG9.gif" alt=""></p><p>這次展示的內容都只是提供大家一個概念<br>實際上可以應用的場景當然不限於圖表、數據呈現<br>DEMO 連結在這邊，歡迎上去玩玩看<br><a href="https://huskylin.github.io/dynamic-component-demo-2/">https://huskylin.github.io/dynamic-component-demo-2/</a></p><p>完整程式碼在 <a href="https://github.com/huskylin/dynamic-component/blob/master/day2/dynamic-component/src/app/pages/custom/custom.component.ts" target="_blank" rel="noopener">Github 專案</a>上</p><p>真心覺得 Angular 的這個功能超酷<br>終於打完這篇的分享啦，灑花<del>~</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用-Angular-動態元件，製作高彈性客製化頁面-下&quot;&gt;&lt;a href=&quot;#利用-Angular-動態元件，製作高彈性客製化頁面-下&quot; class=&quot;headerlink&quot; title=&quot;利用 Angular 動態元件，製作高彈性客製化頁面! (下)&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>利用Angular動態元件，製作高彈性客製化頁面! (上)</title>
    <link href="https://huskylin.github.io/2021/02/18/%E5%88%A9%E7%94%A8Angular%E5%8B%95%E6%85%8B%E5%85%83%E4%BB%B6%EF%BC%8C%E8%A3%BD%E4%BD%9C%E9%AB%98%E5%BD%88%E6%80%A7%E5%AE%A2%E8%A3%BD%E5%8C%96%E9%A0%81%E9%9D%A2-%E4%B8%8A/"/>
    <id>https://huskylin.github.io/2021/02/18/%E5%88%A9%E7%94%A8Angular%E5%8B%95%E6%85%8B%E5%85%83%E4%BB%B6%EF%BC%8C%E8%A3%BD%E4%BD%9C%E9%AB%98%E5%BD%88%E6%80%A7%E5%AE%A2%E8%A3%BD%E5%8C%96%E9%A0%81%E9%9D%A2-%E4%B8%8A/</id>
    <published>2021-02-18T12:09:35.000Z</published>
    <updated>2021-02-19T12:53:12.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用-Angular-動態元件，製作高彈性客製化頁面-上"><a href="#利用-Angular-動態元件，製作高彈性客製化頁面-上" class="headerlink" title="利用 Angular 動態元件，製作高彈性客製化頁面! (上)"></a>利用 Angular 動態元件，製作高彈性客製化頁面! (上)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好! 不知道各位有沒有看過儀表板 (Dashboard) 類型的網頁?<br>主要是由多個圖表或是數據視覺化的元件組成的頁面<br>例如這種:<br><img src="https://i.imgur.com/s9QdJJY.png" alt=""></p><p>(來源: <a href="https://www.akveo.com/ngx-admin/pages/dashboard?theme=default" target="_blank" rel="noopener">ngx-admin</a>)</p><p>我接觸到的業務會大量製作這類型的網頁<br>隨著遇到的需求越來越複雜，用到的功能也越來越進階<br>遇到比較特別的需求是<br><strong>希望可以讓使用者自訂要顯示哪一些圖表，客製化屬於自己想看的頁面</strong></p><p>這時候「先在 HTML 寫好要顯示什麼內容」這種常規的方式就沒有辦法滿足需求了<br><del>更不用說需求往往會在功能做完之後才出現 :)</del><br>所以本系列會和大家分享如何用 Angular 製作高彈性的頁面</p><p>本篇最後完成的結果如下:<br><img src="https://i.imgur.com/9JymQWw.gif" alt=""><br><a href="https://huskylin.github.io/dynamic-component-demo-1/">https://huskylin.github.io/dynamic-component-demo-1/</a></p><p>了解這個功能後<br>也可以達成像是 CakeResume 的客製化履歷、 Wix 的拖拉式網站功能<br>(都是由小元件拖拉而成)</p><p>核心的知識會用到:</p><ol><li><a href="https://angular.io/api/core/ViewContainerRef" target="_blank" rel="noopener">ViewContainerRef</a></li><li><a href="https://angular.io/api/core/ComponentFactory" target="_blank" rel="noopener">ComponentFactory</a></li><li><a href="https://angular.io/api/core/ComponentRef" target="_blank" rel="noopener">ComponentRef</a></li></ol><p>本篇會先一步一步帶大家做出<strong>動態新增元件</strong>這個功能</p><h2 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h2><p>要做的部分可以拆成兩部分來理解</p><h3 id="第一部分，要在頁面上的哪個地方來產生元件"><a href="#第一部分，要在頁面上的哪個地方來產生元件" class="headerlink" title="第一部分，要在頁面上的哪個地方來產生元件?"></a>第一部分，要在頁面上的哪個地方來產生元件?</h3><ol><li>透過 directive 在 .html 檔 上標示之後要產生元件的地方</li><li>透過 ViewChild 或是 ViewChildren 來尋找標記的位置<blockquote><p>註: 如果只有一個地方要生成，用 ViewChild 即可<br>如果有多個才需要 ViewChildren ( 陣列版的 ViewChild )</p></blockquote></li></ol><p><img src="https://i.imgur.com/M0XUJoe.jpg" alt=""></p><h3 id="第二部分，製作要動態生成的元件"><a href="#第二部分，製作要動態生成的元件" class="headerlink" title="第二部分，製作要動態生成的元件"></a>第二部分，製作要動態生成的元件</h3><ol><li>注入 ComponentFactoryResolver</li><li>用 resolveComponentFactory 方法，產生對應的元件</li></ol><p><img src="https://i.imgur.com/WGPuQJS.jpg" alt=""></p><p>最後則是將這兩部分合併起來<br>在找到標記的位置上，將產生出的元件放進來</p><h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><h3 id="先製作-Directive"><a href="#先製作-Directive" class="headerlink" title="先製作 Directive"></a>先製作 Directive</h3><p>dynamic-component-host.directive.ts</p><pre><code class="TypeScript">import { Directive, ViewContainerRef } from &#39;@angular/core&#39;;@Directive({  selector: &#39;[appDynamicComponentHost]&#39;,})export class DynamicComponentHostDirective {  public viewContainerRef = this._viewContainerRef;  constructor(private _viewContainerRef: ViewContainerRef) { }}</code></pre><h3 id="第一部分，找到要標記要生成的位置"><a href="#第一部分，找到要標記要生成的位置" class="headerlink" title="第一部分，找到要標記要生成的位置"></a>第一部分，找到要標記要生成的位置</h3><p>custom.component.ts</p><pre><code class="TypeScript">// 透過 ViewChild 或是 ViewChildren 來尋找標記的位置@ViewChildren(DynamicComponentHostDirective) dcHosts: QueryList&lt;DynamicComponentHostDirective&gt;;constructor() { }createComponent(component) {    this.dcHosts.forEach(host =&gt; {      // 要拿來放元件，view 的參照位置      const vcRef = host.viewContainerRef;    });  }</code></pre><h3 id="第二部分，製作要動態生成的元件-1"><a href="#第二部分，製作要動態生成的元件-1" class="headerlink" title="第二部分，製作要動態生成的元件"></a>第二部分，製作要動態生成的元件</h3><p>custom.component.ts</p><pre><code class="TypeScript">// 透過 ViewChild 或是 ViewChildren 來尋找標記的位置@ViewChildren(DynamicComponentHostDirective) dcHosts: QueryList&lt;DynamicComponentHostDirective&gt;;  constructor(    private cfr: ComponentFactoryResolver,    private utilsService: UtilsService,  ) { }createComponent(component) {    this.dcHosts.forEach(host =&gt; {      // 要拿來放元件，view 的參照位置      const vcRef = host.viewContainerRef;      // 從全部的元件中，選擇要製作出來的元件      const allComponents = this.utilsService.getAllComponents();      const targetComponent: any = allComponents.filter(e =&gt; e.name === component.name)[0].val;      // 用 resolveComponentFactory 方法，產生對應的元件      const componentFactory = this.cfr.resolveComponentFactory(targetComponent);    });  }</code></pre><h3 id="最後產生出元件"><a href="#最後產生出元件" class="headerlink" title="最後產生出元件"></a>最後產生出元件</h3><p>custom.component.ts</p><pre><code class="TypeScript">// 透過 ViewChild 或是 ViewChildren 來尋找標記的位置@ViewChildren(DynamicComponentHostDirective) dcHosts: QueryList&lt;DynamicComponentHostDirective&gt;;  constructor(    private cfr: ComponentFactoryResolver,    private utilsService: UtilsService,  ) { }createComponent(component) {    this.dcHosts.forEach(host =&gt; {      // 要拿來放元件，view 的參照位置      const vcRef = host.viewContainerRef;      // 從全部的元件中，選擇要製作出來的元件      const allComponents = this.utilsService.getAllComponents();      const targetComponent: any = allComponents.filter(e =&gt; e.name === component.name)[0].val;      // 用 resolveComponentFactory 方法，產生對應的元件      const componentFactory = this.cfr.resolveComponentFactory(targetComponent);      // 在要正確的位置上，產生正確的元件      const targetRef = vcRef.createComponent(componentFactory);    });  }</code></pre><h2 id="稍作延伸"><a href="#稍作延伸" class="headerlink" title="稍作延伸"></a>稍作延伸</h2><p>上面的步驟可以簡單的做出動態產生的功能<br>個人在實際應用上，多做了一些延伸</p><ol><li>製作一個容器元件，由容器元件來決定尺寸大小<br>(因為原本的圖表元件大小為 height: 100%, width: 100%)<br>這樣同一個元件在不同頁面中可以套用不同大小，使用上會更有彈性</li><li>利用 renderer2 替動態產生出來的元件，加上 CSS class</li><li>儲存產生的 componentRef，以供之後刪除、修改</li></ol><h3 id="1-容器元件"><a href="#1-容器元件" class="headerlink" title="1. 容器元件"></a>1. 容器元件</h3><p>custom.component.ts</p><pre><code class="TypeScript">承上...// 可以自訂不同尺寸的容器元件wrappers = {    small: SmallComponent,    medium: MediumComponent,    big: BigComponent,};createComponent(component) {      ...      // 製作被選擇要出來的元件，targetComponent 目標功能元件, wrapperComponent 決定大小的外框元件      const allComponents = this.utilsService.getAllComponents();      const targetComponent: any = allComponents.filter(e =&gt; e.name === component.name)[0].val;      const wrapperComponent: any = this.wrappers.small;      const wrapperFactory = this.cfr.resolveComponentFactory(wrapperComponent);      const componentFactory = this.cfr.resolveComponentFactory(targetComponent);      // 先產生目標圖表元件      const targetRef = vcRef.createComponent(componentFactory);      // 在參照位置產生外框元件，並且透過 ng-content，將目標圖表元件放進來      const wrapperRef = vcRef.createComponent(wrapperFactory, vcRef.length, undefined, [[targetRef.location.nativeElement]]);      }</code></pre><p>關於在 viewContainerRef.createComponent() 時使用 ng-content<br>可以進一步參考這篇 <a href="https://stackoverflow.com/questions/44284026/creating-a-angular2-component-with-ng-content-dynamically" target="_blank" rel="noopener">SatckOverflow</a><br>這可以讓你動態產生的元件做出更複雜的變化</p><h3 id="2-加上-CSS-class"><a href="#2-加上-CSS-class" class="headerlink" title="2. 加上 CSS class"></a>2. 加上 CSS class</h3><p>renderer2 可以幫助我們在事後才替元件加上 class、改變樣式<br>用在動態元件上面也是很方便</p><pre><code class="TypeScript">承上...// 注入renderer2constructor(private renderer2: Renderer2) { }createComponent(component) {      ...      const wrapperRef = vcRef.createComponent(wrapperFactory, vcRef.length, undefined, [[targetRef.location.nativeElement]]);      // 用 renderer2 在產生出來的元件上 加上 class      this.renderer2.addClass(wrapperRef.location.nativeElement, YOUR_CLASSNAME_HERE);}</code></pre><h3 id="3-儲存產生的-componentRef"><a href="#3-儲存產生的-componentRef" class="headerlink" title="3. 儲存產生的 componentRef"></a>3. 儲存產生的 componentRef</h3><p>替每次產生出來的元件加上 uniqueKey<br>方便之後在頁面上動態刪除元件<br>(這邊另外開一個 custom.service 來操作)</p><pre><code class="TypeScript">承上...// 簡單用一個 counter 來作為 uniqueKeychildUniqueKey: number = 0;createComponent(component) {      ...      // 在元件的instance內增加一個 uniqueKey 屬性，用來記錄唯一值      wrapperRef.instance[&#39;uniqueKey&#39;] = ++this.childUniqueKey;      // 儲存 wrapper 跟 target 的 ref，之後更新資料、刪除元件時會用      this.customService.pushWrapperRefs(wrapperRef);      this.customService.pushChartRefs(targetRef);}</code></pre><h3 id="綜合以上的程式碼"><a href="#綜合以上的程式碼" class="headerlink" title="綜合以上的程式碼"></a>綜合以上的程式碼</h3><pre><code class="TypeScript">  createComponent(component, isNew) {    this.dcHosts.forEach(host =&gt; {      // 要拿來放元件，view 的參照位置      const vcRef = host.viewContainerRef;      // 製作被選擇要出來的元件，targetComponent 目標功能元件, wrapperComponent 決定大小的外框元件      const allComponents = this.utilsService.getAllComponents();      const targetComponent: any = allComponents.filter(e =&gt; e.name === component.name)[0].val;      const wrapperComponent: any = this.wrappers[&#39;small&#39;];      const wrapperFactory = this.cfr.resolveComponentFactory(wrapperComponent);      const componentFactory = this.cfr.resolveComponentFactory(targetComponent);      // 先產生目標圖表元件      const targetRef = vcRef.createComponent(componentFactory);      // 在參照位置產生外框元件，並且透過 ng-content，將目標圖表元件放進來      const wrapperRef = vcRef.createComponent(wrapperFactory, vcRef.length, undefined, [[targetRef.location.nativeElement]]);      // 用 renderer2 在產生出來的元件上 加上 class      this.renderer2.addClass(wrapperRef.location.nativeElement, YOUR_CLASSNAME_HERE);      // 記錄 component 唯一值      wrapperRef.instance[&#39;uniqueKey&#39;] = ++this.childUniqueKey;      // 儲存 wrapper 跟 target 的 ref，之後更新資料、刪除元件時會用      this.customService.pushWrapperRefs(wrapperRef);      this.customService.pushChartRefs(targetRef);    });  }</code></pre><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><img src="https://i.imgur.com/9JymQWw.gif" alt=""></p><p><a href="https://huskylin.github.io/dynamic-component-demo-1/">https://huskylin.github.io/dynamic-component-demo-1/</a><br>大家可以上去玩玩看</p><p>這裡用三個圖表元件來做簡單的示範<br>可以在原先空白的頁面上<br>自定義想要顯示哪些圖表、如何排列<br>如果每個圖表有不同的篩選條件時(例如:不同時間範圍、地區)<br>更可以達到交叉分析的效果，在數據分析上非常實用</p><p>完整的程式碼在<a href="https://github.com/huskylin/dynamic-component/blob/master/day1/dynamic-component/src/app/pages/custom/custom.component.ts" target="_blank" rel="noopener">Github 專案</a>上</p><p>這次做了動態新增的部分<br>下一篇會延續本篇，完成下列功能</p><ul><li>刪除已經產生出的元件</li><li>在創立 component 時，傳入 Input 資料</li></ul><p>2/19 更新，下一篇在這裡 <a href="https://huskylin.github.io/2021/02/19/利用Angular動態元件，製作高彈性客製化頁面-下/">利用Angular動態元件，製作高彈性客製化頁面! (下)</a></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://netbasal.com/dynamically-creating-components-with-angular-a7346f4a982d" target="_blank" rel="noopener">Dynamically Creating Components with Angular</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10206734" target="_blank" rel="noopener">[Angular 大師之路] Day 15 - 動態載入元件 (複雜版)</a></li><li><a href="https://dotblogs.com.tw/wellwind/2017/06/21/dynamic-component-with-component-factory-resolver" target="_blank" rel="noopener">[Angular 進階議題]使用 ComponentFactoryResolver 動態產生 Component</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用-Angular-動態元件，製作高彈性客製化頁面-上&quot;&gt;&lt;a href=&quot;#利用-Angular-動態元件，製作高彈性客製化頁面-上&quot; class=&quot;headerlink&quot; title=&quot;利用 Angular 動態元件，製作高彈性客製化頁面! (上)&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>此連線並非私人連線? 檢查你的SSL設定等級!</title>
    <link href="https://huskylin.github.io/2021/01/28/%E6%AD%A4%E9%80%A3%E7%B7%9A%E4%B8%A6%E9%9D%9E%E7%A7%81%E4%BA%BA%E9%80%A3%E7%B7%9A-%E6%AA%A2%E6%9F%A5%E4%BD%A0%E7%9A%84SSL%E8%A8%AD%E5%AE%9A%E7%AD%89%E7%B4%9A/"/>
    <id>https://huskylin.github.io/2021/01/28/%E6%AD%A4%E9%80%A3%E7%B7%9A%E4%B8%A6%E9%9D%9E%E7%A7%81%E4%BA%BA%E9%80%A3%E7%B7%9A-%E6%AA%A2%E6%9F%A5%E4%BD%A0%E7%9A%84SSL%E8%A8%AD%E5%AE%9A%E7%AD%89%E7%B4%9A/</id>
    <published>2021-01-28T13:45:33.000Z</published>
    <updated>2023-02-20T12:53:30.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="此連線並非私人連線-檢查你的-SSL-設定等級"><a href="#此連線並非私人連線-檢查你的-SSL-設定等級" class="headerlink" title="此連線並非私人連線? 檢查你的 SSL 設定等級!"></a>此連線並非私人連線? 檢查你的 SSL 設定等級!</h1><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>日前網站被回報說 <strong>用 Safari 開啟時會顯示「此連線並非私人連線」</strong><br>一開始是覺得很奇怪，憑證應該是沒有問題的(不是自簽的而且是政府單位核發的)<br>透過 Chrome 或是 Firefox 開啟時，都是沒有問題的<br>當然是可以透過把這個網站的憑證加入到 Mac 的鑰匙圈存取上<br>手動信任這個網站 來規避問題<br>不過還是要解決才來得痛快<br><img src="https://i.imgur.com/U6GNMep.png" alt=""></p><h2 id="檢查原因"><a href="#檢查原因" class="headerlink" title="檢查原因"></a>檢查原因</h2><p>要檢查自己的 SSL 設定是否完善<br>可使用 <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">SSL Labs</a> 檢測的服務<br>他會偵測你 SSL 設定存在哪些問題、疑慮<br>並且給出一個安全等級的分數</p><p>我的檢測結果為 B 級<br>原因是檢查出「This servers’s <strong>certificate chain</strong> is incomplete.」的問題<br><img src="https://i.imgur.com/ryLVHph.png" alt=""></p><h2 id="什麼是-Certificate-Chain"><a href="#什麼是-Certificate-Chain" class="headerlink" title="什麼是 Certificate Chain ?"></a>什麼是 Certificate Chain ?</h2><blockquote><p>Certificate Chain 中文可翻作 憑證串鏈、信任鏈、數位憑證鏈…等等</p></blockquote><p>憑證主要分三種：</p><ul><li>根憑證（Root Certificate）</li><li>中繼憑證（Intermediate Certificate)</li><li>終端憑證（End-Entity Certificate）</li></ul><p>“通常”是階級式的驗證，像資料結構的樹一樣，根憑證就是根節點，終端憑證是葉節點，其他都是中繼憑證。</p><p>使用網頁瀏覽器造訪一個網站，會執行認證路徑驗證演算法，使用該主機提供的電子憑證，驗證是否能夠對應到預先安裝的根憑證，從而驗證從根憑證到終端節點的路徑是否為一條有效的信任鏈，確保 TLS 安全連接中的身分。</p><p><img src="https://i.imgur.com/sHCu1ZB.png" alt=""></p><p>簡單來說，<strong>憑證是否安全有效，是由一連串的憑證驗證組成的</strong></p><h2 id="解決問題"><a href="#解決問題" class="headerlink" title="解決問題"></a>解決問題</h2><p>在一般情況下，瀏覽器會自動找到對應的 Certificate Chain<br>(憑證中會含有簽發者個資訊，可以一路找下去)<br>所以在 Chrome 及 Firefox 中才沒有遇到這個問題</p><p>不確定為什麼 Safari 會有這個問題<br>但是除了 Safari 以外<br>如果是用 cURL 或是在沒有 internet 環境的網路<br>也無法透過網路去找到 Certificate Chain<br>所以最好的做法就是加上完整的中繼憑證</p><h2 id="加上中繼憑證"><a href="#加上中繼憑證" class="headerlink" title="加上中繼憑證"></a>加上中繼憑證</h2><p>根據 Stack Overflow 上的一篇解答<br><a href="https://stackoverflow.com/a/47292312" target="_blank" rel="noopener">SSL: Servers certificate chain is incomplete</a></p><blockquote><ul><li>open your site in a browser</li><li>click on green padlock and display certificate properties</li><li>export every certificate in the chain</li><li>install new cert on server</li><li>test nginx cofiguration nginx -t</li><li>restart server service nginx restart</li></ul></blockquote><p>提到一個快速的解法是<br>在可以成功連線的瀏覽器上 直接匯出金鑰練<br>並且加入到你目前的憑證中<br>然後重啟 Nginx 設定</p><h2 id="操作範例"><a href="#操作範例" class="headerlink" title="操作範例"></a>操作範例</h2><p>以 Firefox 為例來操作<br><img src="https://i.imgur.com/dBfRc5c.png" alt=""><br>找到檢視憑證後的地方後可以看到<br>上面那一串就是這個憑證的 Certificate Chain<br><img src="https://i.imgur.com/lwi7FMY.png" alt=""><br>瀏覽器有提供下載金鑰練的功能</p><p>打開後的結構會是一連串的</p><pre><code class="TEXT">-----BEGIN CERTIFICATE-----憑證內容-----END CERTIFICATE----------BEGIN CERTIFICATE-----憑證內容-----END CERTIFICATE-----...</code></pre><blockquote><p>看你有幾個憑證節點 就會有幾個 BEGIN … END</p></blockquote><p>最終更新原本網站的憑證<br>然後刷新 Nginx 設定 ( reload 後才會生效 )</p><p>完成後再測驗一次<br>拿到了 A 級<br>(最高可以到 A+ 的 100 分，不過也會犧牲一些效能及支援度)<br><img src="https://i.imgur.com/1AdWim4.png" alt=""></p><p>最後當然也就可以成功在 Safari 上正常瀏覽網站啦!<br>灑花~</p><p>回顧一下本文的重點</p><ul><li>利用 SSL Labs 檢查網站</li><li>Certificate Chain 是什麼</li><li>如何加上完整的 Certificate Chain</li><li>要支援 Safari 瀏覽器需要注意 SSL 的問題</li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.tangzongchao.com/2016/02/24/HTTPS%E4%B8%AD%E8%AF%81%E4%B9%A6%E9%93%BE%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">HTTPS 中证书链不完整的解决方案</a></li><li><a href="https://shazi.info/openssl-%E6%AA%A2%E6%B8%AC-ssl-%E7%9A%84%E6%86%91%E8%AD%89%E4%B8%B2%E9%8D%8A-certificate-chain/" target="_blank" rel="noopener">OpenSSL 檢測 SSL 的憑證串鍊</a></li><li><a href="http://qbsuranalang.blogspot.com/2017/05/openssl-certificate-chain-included-san.html" target="_blank" rel="noopener">OpenSSL Certificate Chain</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E8%AF%81%E4%B9%A6" target="_blank" rel="noopener">維基百科: 根憑證</a></li><li><a href="https://medium.com/@Negaihoshi/%E5%A6%82%E4%BD%95%E5%9C%A8-ssl-labs-%E6%8B%BF%E5%88%B0-100-%E5%88%86-7337428d6b22" target="_blank" rel="noopener">如何在 SSL Labs 拿到 100 分</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;此連線並非私人連線-檢查你的-SSL-設定等級&quot;&gt;&lt;a href=&quot;#此連線並非私人連線-檢查你的-SSL-設定等級&quot; class=&quot;headerlink&quot; title=&quot;此連線並非私人連線? 檢查你的 SSL 設定等級!&quot;&gt;&lt;/a&gt;此連線並非私人連線? 檢查你的
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>備份在Docker中的Gitlab資料 (Backup Gitlab in Docker)</title>
    <link href="https://huskylin.github.io/2021/01/01/%E5%82%99%E4%BB%BD%E5%9C%A8Docker%E4%B8%AD%E7%9A%84Gitlab%E8%B3%87%E6%96%99-Backup-Gitlab-in-Docker/"/>
    <id>https://huskylin.github.io/2021/01/01/%E5%82%99%E4%BB%BD%E5%9C%A8Docker%E4%B8%AD%E7%9A%84Gitlab%E8%B3%87%E6%96%99-Backup-Gitlab-in-Docker/</id>
    <published>2021-01-01T11:58:13.000Z</published>
    <updated>2023-02-20T12:52:25.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="備份在Docker中的Gitlab資料-Backup-Gitlab-in-Docker"><a href="#備份在Docker中的Gitlab資料-Backup-Gitlab-in-Docker" class="headerlink" title="備份在Docker中的Gitlab資料 (Backup Gitlab in Docker)"></a>備份在Docker中的Gitlab資料 (Backup Gitlab in Docker)</h1><h2 id="查看Gitlab的設定值"><a href="#查看Gitlab的設定值" class="headerlink" title="查看Gitlab的設定值"></a>查看Gitlab的設定值</h2><p>Gitlab 的設定值由<code>gitlab.rb</code>這個檔案控管<br>先找到這個檔案的路徑，確認看看是否有要修改的地方</p><p>由於是服務是運行在 Docker 的 Container 裡面<br>根據執行時是否加入 Volume 參數</p><ul><li>如果有設定 Docker 的 Volume<ul><li>可以直接去當初 volume 設定的本地路徑</li></ul></li><li>如果沒有，就得進到 Container 裡面去找<ul><li>進到 Container <code>docker attach gitlab</code></li><li>查看與修改設定 <code>sudo nano /etc/gitlab/</code></li></ul></li></ul><blockquote><p>Volume 可以使 Container 裡面的檔案路徑<br>對應到實體主機的檔案路徑<br>例如: –volume /gitlab/config:/etc/gitlab<br>會使本地的 /gitlab/config 對應到 Container 裡的 /etc/gitlab</p></blockquote><h2 id="修改、確認設定值"><a href="#修改、確認設定值" class="headerlink" title="修改、確認設定值"></a>修改、確認設定值</h2><p><code>gitlab.rb</code> 裡面的備份設定區塊<br>可以設定</p><ul><li>是否要啟用備份</li><li>備份到哪個路徑</li><li>備份出來的檔案權限</li><li>備份哪個schema</li><li>備份出來的檔案，多久後過期 (預設為7天)</li></ul><pre><code class="Bash">### Backup Settings###! Docs: https://docs.gitlab.com/omnibus/settings/backups.htmlgitlab_rails[&#39;manage_backup_path&#39;] = truegitlab_rails[&#39;backup_path&#39;] = &quot;/var/opt/gitlab/backups&quot;###! Docs: https://docs.gitlab.com/ce/raketasks/backup_restore.html#backup-   archive-permissionsgitlab_rails[&#39;backup_archive_permissions&#39;] = 0644gitlab_rails[&#39;backup_pg_schema&#39;] = &#39;public&#39;###! The duration in seconds to keep backups before they are allowed to be deletedgitlab_rails[&#39;backup_keep_time&#39;] = 604800</code></pre><p>如果這些預設值都已經符合需求<br>就可以直接前往下一步<br>如果有修改<br>就需要在儲存後，執行刷新設定的指令</p><pre><code class="Bash">## In Containergitlab-ctl reconfigure## 在本機執行，前面要加上 docker exec -it gitlabdocker exec -it gitlab gitlab-ctl reconfigure</code></pre><h2 id="執行備份"><a href="#執行備份" class="headerlink" title="執行備份"></a>執行備份</h2><p>執行指令</p><pre><code class="Bash">## In Containergitlab-rake gitlab:backup:create## 在本機執行，前面要加上 docker exec -it gitlabdocker exec -it gitlab-rake gitlab:backup:create</code></pre><p>跑出一大堆東西後就可以去看<br>備份路徑內是否出現了 gitlab_backup.tar 的備份檔案</p><pre><code class="Bash">Creating backup archive: 1609235127_2020_12_29_12.9.2_gitlab_backup.tar ... doneUploading backup archive to remote storage  ... skippedDeleting tmp directories ... donedonedone...</code></pre><h2 id="利用-Crontab-來自動執行備份"><a href="#利用-Crontab-來自動執行備份" class="headerlink" title="利用 Crontab 來自動執行備份"></a>利用 Crontab 來自動執行備份</h2><p>測試完可以手動備份後<br>來建立要執行的腳本<br>以及設定 Crontab 的排程計畫</p><h3 id="創建要執行的-shell-script"><a href="#創建要執行的-shell-script" class="headerlink" title="創建要執行的 shell script"></a>創建要執行的 shell script</h3><pre><code class="Bash">#!/bin/bashdocker exec -i gitlab gitlab-rake gitlab:backup:create</code></pre><p>這邊值得注意的是<br>前面的指令<code>docker exec -it</code><br>這裡要改成<code>docker exec -i</code><br>在 Crontab 執行時加入 -t 參數會有錯誤</p><blockquote><p>Docker 的 exec 指令參數為:<br>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]<br>（-d:背景進行；-i：保持STDIN打開，看到印出結果；-t:分配一個虛擬終端）<br><a href="https://docs.docker.com/engine/reference/commandline/exec/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/exec/</a></p></blockquote><h3 id="創建-Crontab-的排程計畫"><a href="#創建-Crontab-的排程計畫" class="headerlink" title="創建 Crontab 的排程計畫"></a>創建 Crontab 的排程計畫</h3><p>下面的例子是 每天 22:30 的時候執行備份的 shell script<br>並且將印出的 log 重導放置於 cronlog.txt<br>以供出錯時查看</p><pre><code class="Bash"># backup gitlab30 22 * * * /bin/sh /gitlab/data/backups/auto_backup.sh &gt; /gitlab/data/backups/cronlog.txt 2&gt;&amp;1</code></pre><h3 id="刪除多餘的備份檔"><a href="#刪除多餘的備份檔" class="headerlink" title="刪除多餘的備份檔?"></a>刪除多餘的備份檔?</h3><p>在其他文章有看到<br>他另外建立了刪除備份檔的 shell script 與 排程<br>不過經測試後發現<br><strong>由於前面已經設置了備份過期的時間</strong><br>gitlab.rb 的 <code>gitlab_rails[&#39;backup_keep_time&#39;]</code><br>所以在每次執行備份指令時<br><strong>會檢查哪些備份檔已經過期<br>並且自動刪除</strong><br>如下面範例的最後一行</p><pre><code class="Bash">Creating backup archive: 1609235127_2020_12_29_12.9.2_gitlab_backup.tar ... doneUploading backup archive to remote storage  ... skippedDeleting tmp directories ... donedonedonedonedonedonedonedoneDeleting old backups ... done. (2 removed)</code></pre><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://blog.toright.com/posts/5831/%E4%B8%89%E7%A7%92%E6%95%99%E4%BD%A0%E7%94%A8-docker-%E5%AE%89%E8%A3%9D-gitlab.html" target="_blank" rel="noopener">三秒教你用 Docker 安裝 GitLab</a></li><li><a href="https://www.cnblogs.com/linyouyi/p/10753569.html" target="_blank" rel="noopener">gitlab自动备份和定时删除</a></li><li><a href="https://joshhu.gitbooks.io/dockercommands/content/Containers/IntoContainers.html" target="_blank" rel="noopener">在外部執行Container內的程式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;備份在Docker中的Gitlab資料-Backup-Gitlab-in-Docker&quot;&gt;&lt;a href=&quot;#備份在Docker中的Gitlab資料-Backup-Gitlab-in-Docker&quot; class=&quot;headerlink&quot; title=&quot;備份在Doc
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機</title>
    <link href="https://huskylin.github.io/2020/11/16/%E6%BD%9B%E8%83%BD%E8%A7%A3%E6%94%BE%EF%BC%81%E4%BD%A0%E7%9A%84Andriod%E6%89%8B%E6%A9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E6%AD%A2%E6%96%BC%E6%AD%A4%EF%BC%81%E6%89%8B%E6%A9%9F%E4%B8%AD%E7%9A%84%E8%99%9B%E6%93%AC%E6%A9%9F/"/>
    <id>https://huskylin.github.io/2020/11/16/%E6%BD%9B%E8%83%BD%E8%A7%A3%E6%94%BE%EF%BC%81%E4%BD%A0%E7%9A%84Andriod%E6%89%8B%E6%A9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E6%AD%A2%E6%96%BC%E6%AD%A4%EF%BC%81%E6%89%8B%E6%A9%9F%E4%B8%AD%E7%9A%84%E8%99%9B%E6%93%AC%E6%A9%9F/</id>
    <published>2020-11-16T15:15:32.000Z</published>
    <updated>2023-02-20T12:53:39.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機"><a href="#潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機" class="headerlink" title="潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機"></a>潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機</h1><h2 id="你聽過刷機嗎"><a href="#你聽過刷機嗎" class="headerlink" title="你聽過刷機嗎?"></a>你聽過刷機嗎?</h2><p>有在玩手機的應該多少聽過<code>root</code>, <code>刷機</code><br>甚至一些框架<code>Xposed</code>, <code>Magisk</code><br>只要動了一些手腳<br>就可以使用許多炫炮與實用兼具的功能<br>例如:</p><ul><li>改系統樣式<ul><li>GravityBox</li></ul></li><li>系統優化<ul><li>綠色守護(Greenify)</li></ul></li><li>阻擋廣告<ul><li>AdAway</li><li>MinMinGuard</li></ul></li><li>假定位<ul><li>Fake GPS location</li></ul></li><li>修改遊戲數值<ul><li>GameGuardian</li></ul></li><li>Line隱藏已讀<ul><li>LineHack</li></ul></li><li>網易雲音樂破解<ul><li>音量放大器</li></ul></li></ul><p>一堆奇奇怪怪、五花八門的功能<br>雖然上述很多知名的套件<br>放在現在的時空已經不再那麼需要<br>或是停止維護了<br>但還是有很多好用的功能<br>仍然是一般手機辦不到的<br>「別人不能，我可以」的感覺就是很爽<br>這些高度自訂化的功能也是我喜愛Android系統的原因</p><h2 id="刷機有什麼缺點"><a href="#刷機有什麼缺點" class="headerlink" title="刷機有什麼缺點?"></a>刷機有什麼缺點?</h2><p>因為上述的這些權限、框架<br>除了比較有<code>技術門檻</code>以外<br>更重要的是，基本上都會<code>使手機失去保固</code><br>雖然有可能還是會讓你維修，但就完全是看運氣<br>畢竟名義上就已經是失去保固了<br>而且<code>root</code>也會讓手機變得更不安全</p><h2 id="我想使用這些功能又不想刷機"><a href="#我想使用這些功能又不想刷機" class="headerlink" title="我想使用這些功能又不想刷機"></a>我想使用這些功能又不想刷機</h2><p>我自己用過的每一隻智慧型手機，都固定會刷機<br>(自己的就刷了5隻，再加上幫親朋好友的加一加，應該刷了10幾隻)<br>每次刷機都需要執行繁複的手續<br>或是要等到保固過期後才敢放心刷機</p><p>直到後來有人做出了<br>在Android上的虛擬機環境<code>VirtualApp</code><br>並且陸續有人以此開發出<br>可以在裝在虛擬機環境中的<code>Xposed</code>框架:<br><code>VirtualXpose</code>、以及後來的<code>太極 Tai Chi</code><br>一切都變得方便許多</p><p>他會先創建一個虛擬環境<br>並且將<code>Xposed</code>框架裝在這個虛擬的環境中<br>所以自己的手機不需要<code>root</code>或是解鎖<code>BootLoader</code><br>就可以使用<code>Xposed</code>框架了</p><h2 id="示範"><a href="#示範" class="headerlink" title="示範"></a>示範</h2><ol><li>先到官網下載安裝<br><a href="https://taichi.cool/" target="_blank" rel="noopener">https://taichi.cool/</a><br>也可以順便看看官網上的介紹<br><img src="https://i.imgur.com/0jZxbsA.png" alt=""></li><li>安裝完之後可以找一下自己喜歡的模組</li><li>這邊以一款廣告阻擋DNS為例子</li></ol><table><thead><tr><th>安裝程式列表</th><th>廣告阻擋程式</th></tr></thead><tbody><tr><td>![](<a href="https://i.imgur.com/jgXaUFx.jpg" target="_blank" rel="noopener">https://i.imgur.com/jgXaUFx.jpg</a> =270x518)</td><td>![](<a href="https://i.imgur.com/FMv02pZ.jpg" target="_blank" rel="noopener">https://i.imgur.com/FMv02pZ.jpg</a> =270x518)</td></tr></tbody></table><p>開啟DNS66之後<br>原本程式的最下面有廣告<br>就被擋掉了</p><table><thead><tr><th>Before</th><th>After</th></tr></thead><tbody><tr><td>![](<a href="https://i.imgur.com/Z0OS1om.jpg" target="_blank" rel="noopener">https://i.imgur.com/Z0OS1om.jpg</a> =270x518)</td><td>![](<a href="https://i.imgur.com/6j61Wat.jpg" target="_blank" rel="noopener">https://i.imgur.com/6j61Wat.jpg</a> =270x518)</td></tr></tbody></table><p>更多模組可以參考官網<br><a href="https://taichi.cool/zh/module/" target="_blank" rel="noopener">https://taichi.cool/zh/module/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機&quot;&gt;&lt;a href=&quot;#潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機&quot; class=&quot;headerlink&quot; title=&quot;潛能解放！你的Andriod手機可以不止於此！手機中的虛擬機&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="其他" scheme="https://huskylin.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>好用的AI自動配色工具! 可以直接匯出套用!</title>
    <link href="https://huskylin.github.io/2020/10/24/%E5%A5%BD%E7%94%A8%E7%9A%84AI%E8%87%AA%E5%8B%95%E9%85%8D%E8%89%B2%E5%B7%A5%E5%85%B7-%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%8C%AF%E5%87%BA%E5%A5%97%E7%94%A8/"/>
    <id>https://huskylin.github.io/2020/10/24/%E5%A5%BD%E7%94%A8%E7%9A%84AI%E8%87%AA%E5%8B%95%E9%85%8D%E8%89%B2%E5%B7%A5%E5%85%B7-%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%8C%AF%E5%87%BA%E5%A5%97%E7%94%A8/</id>
    <published>2020-10-24T15:44:57.000Z</published>
    <updated>2023-02-20T12:52:43.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好用的AI自動配色工具-可以直接匯出套用"><a href="#好用的AI自動配色工具-可以直接匯出套用" class="headerlink" title="好用的AI自動配色工具! 可以直接匯出套用!"></a>好用的AI自動配色工具! 可以直接匯出套用!</h1><h2 id="配色工具介紹"><a href="#配色工具介紹" class="headerlink" title="配色工具介紹"></a>配色工具介紹</h2><p><a href="https://colors.eva.design/" target="_blank" rel="noopener">https://colors.eva.design/</a><br>在眾多配色網站中，這款成為我少數幾個有加入標籤的網站<br>他透過深度學習，快速產生具有美感的顏色並且能夠直接匯出使用!!</p><ol><li>選擇主色之後，自動幫你產生網站中常用的功能型配色<br> 喜歡的話可以鎖住保留，不喜歡的話可以一直刷新<br> <img src="https://i.imgur.com/LGtxkxp.gif" alt=""></li><li>調整出喜歡的顏色後，可以匯出成多種格式<br> 包括 Akveo 自家的 Nebular 主題格式，以及常見的 JSON 格式<br> <img src="https://i.imgur.com/N3RuC8m.png" alt=""></li><li>以 Nebular 主題為例，打開來會長這樣<br> 可以很方便地加入到 Nebular 中做自訂主題<br> <img src="https://i.imgur.com/V45whmd.png" alt=""></li></ol><h2 id="選完喜歡的配色，套用到主題中"><a href="#選完喜歡的配色，套用到主題中" class="headerlink" title="選完喜歡的配色，套用到主題中"></a>選完喜歡的配色，套用到主題中</h2><ol><li>將匯出的檔案加入到themes.scss</li></ol><pre><code class="SCSS">$nb-themes: nb-register-theme(  (    color-primary-100: rgba(219, 253, 246, 1),    color-primary-200: rgba(184, 252, 243, 1),    color-primary-300: rgba(146, 246, 241, 1),    ...    ...  custom-theme,  default  );</code></pre><ol start="4"><li>在子元件中需要用到變數的 SCSS 檔案中<br> 引入主題的樣式變數<br> 例如: 將 text-color 這個 class 的顏色設定為主色</li></ol><pre><code class="SCSS">@import &#39;src/app/@theme/styles/themes.scss&#39;;.text-color{  color: nb-theme(color-primary-500);}</code></pre><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>如果是本來就在用 Nebular 主題的一定要試試看<br>就算不是，一般使用上也非常好用<br>產生出來的顏色都頗有質感<br>快點收藏起來吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;好用的AI自動配色工具-可以直接匯出套用&quot;&gt;&lt;a href=&quot;#好用的AI自動配色工具-可以直接匯出套用&quot; class=&quot;headerlink&quot; title=&quot;好用的AI自動配色工具! 可以直接匯出套用!&quot;&gt;&lt;/a&gt;好用的AI自動配色工具! 可以直接匯出套用!&lt;/
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>Redis 做資料快取的基本使用 (搭配Node.js)</title>
    <link href="https://huskylin.github.io/2020/07/10/Redis-%E5%81%9A%E8%B3%87%E6%96%99%E5%BF%AB%E5%8F%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E6%90%AD%E9%85%8DNode-js/"/>
    <id>https://huskylin.github.io/2020/07/10/Redis-%E5%81%9A%E8%B3%87%E6%96%99%E5%BF%AB%E5%8F%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E6%90%AD%E9%85%8DNode-js/</id>
    <published>2020-07-10T10:11:48.000Z</published>
    <updated>2023-02-20T12:52:13.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-做資料快取的基本使用-搭配Node-js"><a href="#Redis-做資料快取的基本使用-搭配Node-js" class="headerlink" title="Redis 做資料快取的基本使用 (搭配Node.js)"></a>Redis 做資料快取的基本使用 (搭配Node.js)</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有些需要耗費大量運算的結果<br>如果能夠在伺服器端做快取<br>可以對效能提升很有幫助<br>先看這次的結果<br><img src="https://i.imgur.com/cauSYoG.png" alt=""><br>左邊為原始情況，右邊為 Redis 快取後<br>(極端案例? T__T</p><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>已經有安裝<br>或是只是想看介紹的可以跳過這部分喔~</p><h3 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h3><p>建議採用官網這種下載壓縮檔再安裝的方式<br>不然直接用 apt-get 常常預設的不是最新版本<br><a href="https://redis.io/download#installation" target="_blank" rel="noopener">https://redis.io/download#installation</a></p><pre><code class="Bash">$ wget http://download.redis.io/releases/redis-6.0.5.tar.gz$ tar xzf redis-6.0.5.tar.gz$ cd redis-6.0.5$ make</code></pre><p>在背景啟動 redis-server</p><pre><code class="Bash">$ src/redis-server --daemonize yes</code></pre><p>並且測試一下功能運作正常</p><pre><code class="Bash">$ redis&gt; set foo bar$ OK$ redis&gt; get foo$ &quot;bar&quot;</code></pre><h3 id="Redis-Client"><a href="#Redis-Client" class="headerlink" title="Redis Client"></a>Redis Client</h3><p>我自己是使用 Node.js<br>所以先安裝 node-redis 套件<br><a href="https://github.com/NodeRedis/node-redis" target="_blank" rel="noopener">https://github.com/NodeRedis/node-redis</a></p><pre><code class="Bash">npm install redis</code></pre><p>Github 上的範例也很簡潔清楚</p><pre><code class="JavaScript">&lt;!-- 引入模組 --&gt;const redis = require(&quot;redis&quot;);const client = redis.createClient();&lt;!-- 連接 redis server --&gt;client.on(&quot;error&quot;, function(error) {  console.error(error);});&lt;!-- 設置與取得 key / value --&gt;client.set(&quot;key&quot;, &quot;value&quot;, redis.print);client.get(&quot;key&quot;, redis.print);</code></pre><h2 id="實際使用"><a href="#實際使用" class="headerlink" title="實際使用"></a>實際使用</h2><h3 id="使用快取的邏輯"><a href="#使用快取的邏輯" class="headerlink" title="使用快取的邏輯"></a>使用快取的邏輯</h3><ul><li>查詢資料時，查看是否存在於快取之中<ul><li>是，則<strong>從快取中取得</strong>資料<ul><li>直接回傳給前端</li></ul></li><li>否，則<strong>從資料庫中</strong>查詢<ul><li>回傳給前端</li><li>並且寫入快取之中</li></ul></li></ul></li><li>更新資料時，查看是否存在於快取之中<ul><li>是，則一併更新快取資料</li><li>否，則寫入快取中<h3 id="轉換為程式碼"><a href="#轉換為程式碼" class="headerlink" title="轉換為程式碼"></a>轉換為程式碼</h3></li></ul></li></ul><pre><code class="Javascript">// 取得圖表資料router.get(&#39;/someData&#39;, (req, res) =&gt; {  // 取得請求參數並傳換成 key  const parm1 = req.query.parm1  const parm2 = req.query.parm2  const parm3 = req.query.parm3  const key = (`someData:${parm1}/${parm2}/${parm3}`).trim()  const expireDay = 60 * 60 * 24;  // 檢查資料是否能夠從快取中取得  redisClient.get(key, (err, rawdata) =&gt; {    // 可以做錯誤處理    if (err) {      console.log(err)    }    // 如果快取中沒有這筆資料，會回傳 null     if (!!rawdata) {      // redis 無法儲存 Javascript 的 Object      // 這邊是直接存成 string      // 所以需要轉換      const data = JSON.parse(rawdata);      return res.json(data);    }    // 這邊是呼叫你撈資料庫的 function    yourSQL.queryData(parm1, parm2, parm3)      .then(results =&gt; {        // 寫入快取，並且設置有效期限為一天        redisClient.set(key, JSON.stringify(results), &#39;EX&#39;, expireDay, err =&gt; {          if (err) {            console.log(err)          }        });        // 回傳資料        res.json(results);      })      .catch(err =&gt; {        // 資料庫的查詢的錯誤處理        console.log(&quot;not connected due to error: &quot; + err);        res.status(500).send(&#39;Can not connect to DB&#39;);      });  });});</code></pre><h2 id="值得注意的地方"><a href="#值得注意的地方" class="headerlink" title="值得注意的地方"></a>值得注意的地方</h2><h3 id="key-的取名"><a href="#key-的取名" class="headerlink" title="key 的取名"></a>key 的取名</h3><p>因為 key 的長度會影響到 Redis 查詢的效能<br>所以設計好的 key 是需要的<br>關乎取名的東西要複雜都可以很複雜<br>但我覺得最大原則就是內部溝通好、好管理就好<br>可以參考 SatckOverflow 上有人講到常見的命名方式<br><a href="https://stackoverflow.com/questions/6965451/redis-key-naming-conventions" target="_blank" rel="noopener">redis-key-naming-conventions</a></p><blockquote><p>We use a colon (:) as namespace separator and a hash (#) for id-parts of keys, e.g.:<br>logistics:building#23</p></blockquote><h3 id="value-的資料型態"><a href="#value-的資料型態" class="headerlink" title="value 的資料型態"></a>value 的資料型態</h3><p>Redis 目前有五種資料型態:</p><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>zset (sorted set)</li></ul><p>我這邊原本是想直接把資料庫撈出來的結果 (Object型態) 存入<br>但是因為 Redis 並沒有這種資料型態<br>所以就直接粗暴的轉成字串<br>存入與取出時透過<code>JSON.stringify</code>, <code>JSON.parse</code> 來處理<br><img src="https://media.giphy.com/media/3oEduNF7DlpxgcHVJe/giphy.gif" alt=""><br>應該有更好的做法啦</p><h3 id="有效期限的設置"><a href="#有效期限的設置" class="headerlink" title="有效期限的設置"></a>有效期限的設置</h3><ul><li>如果不是需要常駐的資料<br>  盡量都要設置有效期限<br>  (需要常駐的資料也應該要記得存於實體資料庫中)</li><li>設置合理的有效期限<ul><li>太長，占用記憶體空間</li><li>太短，容易重覆讀寫浪費效能</li></ul></li><li>在範例的 Node.js 中<br>  語法為在 set 方法裡傳入參數 <code>&#39;EX&#39;, expire</code><pre><code class="JavaScript">  redisClient.set(key, value, &#39;EX&#39;, expire, err =&gt; {      ...  });</code></pre></li></ul><h3 id="超過記憶體上限後的處理、淘汰機制"><a href="#超過記憶體上限後的處理、淘汰機制" class="headerlink" title="超過記憶體上限後的處理、淘汰機制"></a>超過記憶體上限後的處理、淘汰機制</h3><ul><li>noeviction:<br>  即使記憶體上達到上限，也不置換 key-value<br>  也就是<strong>記憶體滿了之後，只能讀取資料，不能寫入</strong><br>  若再新增資料會 return error<blockquote><p><strong>這是預設值，我認為不適用於多數場合，所應該要去設定成下列其他的</strong></p></blockquote></li><li>allkeys-lru:<br>  優先刪除掉<strong>最近最少使用</strong>的key，用以保存新數據<blockquote><p>LRU = least recently used<br>適用多數場合</p></blockquote></li><li>volatile-lru:<br>  只從有設置<strong>有效期限</strong> (expire) 的資料中<br>  選擇<strong>最近最少使用</strong>的 key-value 進行刪除<blockquote><p>與 allkeys-lru 的差別在於<br>一個從<strong>全部</strong>的 key 中來選擇刪除<br>一個是只會從<strong>有有效期限</strong>的 key 來選擇刪除</p></blockquote></li><li>allkeys-random:<br>  從<strong>全部</strong>的 key 中<br>  <strong>隨機選擇</strong>一些進行刪除</li><li>volatile-random:<br>  只從有設置<strong>有效期限</strong> (expire) key 中<br>  <strong>隨機選擇</strong>一些 key 進行刪除</li><li>volatile-ttl:<br>  只從有設置<strong>有效期限</strong> (expire) key 中<br>  選出<strong>剩餘存活時間 (TTL) 最短</strong>的 key 進行刪除<blockquote><p>TTL = Time To Live</p></blockquote></li></ul><h3 id="其他參考資料"><a href="#其他參考資料" class="headerlink" title="其他參考資料"></a>其他參考資料</h3><ul><li><a href="https://medium.com/10coding/node-js-%E4%BD%BF%E7%94%A8-redis-%E5%85%A7%E5%AD%98%E4%BE%86%E5%AD%98%E5%8F%96%E6%9C%AC%E5%9C%B0%E8%B3%87%E6%96%99-9557660196f4" target="_blank" rel="noopener">[Node.js] 使用 Redis 內存來存取本地資料</a></li><li><a href="https://jinguoxing.github.io/redis/2018/10/10/redis-EXPIRE/" target="_blank" rel="noopener">Redis的过期策略及淘汰策略</a></li><li><a href="https://juejin.im/post/5ed5cc9b51882543393c985c" target="_blank" rel="noopener">Redis删除策略和逐出策略</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis-做資料快取的基本使用-搭配Node-js&quot;&gt;&lt;a href=&quot;#Redis-做資料快取的基本使用-搭配Node-js&quot; class=&quot;headerlink&quot; title=&quot;Redis 做資料快取的基本使用 (搭配Node.js)&quot;&gt;&lt;/a&gt;Redis 
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 在每個群組中取 N 筆資料 ( Get 1...N Results From Each Group )</title>
    <link href="https://huskylin.github.io/2020/06/28/MySQL-%E5%9C%A8%E6%AF%8F%E5%80%8B%E7%BE%A4%E7%B5%84%E4%B8%AD%E5%8F%96-N-%E7%AD%86%E8%B3%87%E6%96%99-Get-1-N-Results-From-Each-Group/"/>
    <id>https://huskylin.github.io/2020/06/28/MySQL-%E5%9C%A8%E6%AF%8F%E5%80%8B%E7%BE%A4%E7%B5%84%E4%B8%AD%E5%8F%96-N-%E7%AD%86%E8%B3%87%E6%96%99-Get-1-N-Results-From-Each-Group/</id>
    <published>2020-06-28T07:27:47.000Z</published>
    <updated>2023-02-20T12:51:54.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-在每個群組中取-N-筆資料-Get-1…N-Results-From-Each-Group"><a href="#MySQL-在每個群組中取-N-筆資料-Get-1…N-Results-From-Each-Group" class="headerlink" title="MySQL 在每個群組中取 N 筆資料 ( Get 1…N Results From Each Group )"></a>MySQL 在每個群組中取 N 筆資料 ( Get 1…N Results From Each Group )</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果只想撈取 GROUP BY 後，每一個 GROUP 裡面的前 1…n 筆資料<br>例如:</p><table><thead><tr><th>Person</th><th>Height</th><th>Weight</th><th>UpdateTime</th></tr></thead><tbody><tr><td>Andy</td><td>150</td><td>52</td><td>2018-06-01</td></tr><tr><td>Andy</td><td>155</td><td>55</td><td>2019-08-01</td></tr><tr><td>Andy</td><td>160</td><td>58</td><td>2020-09-01</td></tr><tr><td>Bob</td><td>162</td><td>57</td><td>2018-06-01</td></tr><tr><td>Bob</td><td>164</td><td>62</td><td>2019-08-01</td></tr><tr><td>Bob</td><td>168</td><td>65</td><td>2020-09-01</td></tr></tbody></table><p>這是一張記錄身高體重的表<br>而決定每筆資料是唯一的 PK 就是<code>Person + UpdateTime</code></p><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>假設想要取得<code>每個人最新的體態資料</code><br>那麼直覺就會想到先把他們 GROUP BY 後<br>再來用 ORDER BY<br>再來用 LIMIT<br>再來用….. 到底要用啥<br>最後腦袋一片渾沌地組出一坨勉強通過語法檢查的式子</p><pre><code class="SQL">SELECT     Person, Height, Weight, UpdateTimeFROM    BodyInfoTable GROUP BY    Person, UpdateTimeORDER BY    UpdateTime DESCLIMIT 1</code></pre><p>然後就可以開開心心地看見…<br><strong>各種錯誤與不是你想要的結果 :)</strong><br><img src="https://media.giphy.com/media/xTeV7FKRuo5YX714L6/giphy.gif" alt=""></p><h2 id="解法一，使用-Variables"><a href="#解法一，使用-Variables" class="headerlink" title="解法一，使用 Variables"></a>解法一，使用 Variables</h2><p>那麼再來就是這次的主題<br><strong>針對每一個 GROUP 取幾筆資料</strong><br>查詢了 StackOverflow 上的問答後的解法<br><a href="https://stackoverflow.com/questions/53373326/using-limit-within-group-by-to-get-n-results-per-dynamic-group" target="_blank" rel="noopener">Using LIMIT within GROUP BY to get N results per dynamic group</a><br><a href="https://stackoverflow.com/a/12005119" target="_blank" rel="noopener">mysql limit inside group</a><br>套用在範例的情境中就會長這樣</p><pre><code class="SQL">SELECT     Person, Height, Weight, UpdateTimeFROM    (SELECT         x.*,            CASE                WHEN @prev = Person THEN @i:=@i + 1                ELSE @i:=1            END i,            @prev:=Person    FROM        BodyInfoTable x, (SELECT @prev:=NULL, @i:=0) vars    ORDER BY Person, UpdateTime ) aWHERE    i &lt;= 1;</code></pre><p>最關鍵的部分就是它使用了<a href="https://dev.mysql.com/doc/refman/8.0/en/user-variables.html" target="_blank" rel="noopener"><code>Variables</code></a>搭配<code>case-when</code>來完成<br>當 Person 欄位重覆的時候 i 就會 +1<br>調整 ORDER BY 與 i &lt;= 多少<br>就可以決定想要按照什麼條件來取得前 n 筆資料了</p><p>Variables 變數:</p><pre><code class="SQL">@prev:=Person</code></pre><blockquote><p>You can <strong>store a value in a user-defined variable</strong> in one statement and refer to it later in another statement. This enables you to pass values from one statement to another. </p></blockquote><h3 id="出現另一個問題"><a href="#出現另一個問題" class="headerlink" title="出現另一個問題"></a>出現另一個問題</h3><p>原本想說大功告成，這長得這麼<del>醜</del>複雜<br>把它儲存成 View 吧<br>登愣<del>~</del> 直接噴出一個大大的錯誤<br><code>Error 1351: View&#39;s SELECT contains a variable or parameter SQL Statement:...</code><br>直接拿錯誤餵狗後才知道<br><strong>View 裡面是不能使用 Variables 的!!</strong><br>如果堅持要用，就必須用<a href="https://stackoverflow.com/a/11294609" target="_blank" rel="noopener">很 tricky 的寫法</a><br>看到這邊…我只能說<br>「我OK，你先用」<br><img src="https://media.giphy.com/media/ANWIS2HYfROI8/giphy.gif" alt=""><br>馬上跳槽用別的寫法</p><h2 id="解法二，使用-ROW-NUMBER"><a href="#解法二，使用-ROW-NUMBER" class="headerlink" title="解法二，使用 ROW_NUMBER()"></a>解法二，使用 ROW_NUMBER()</h2><p>原來這種類型的操作<br>是因為在<code>MySQL 8</code>以前才需要這麼克難、展現手做職人精神<br><code>MySQL 8</code>以後就直接用超棒棒函數就好啦<br><a href="https://stackoverflow.com/a/30269273" target="_blank" rel="noopener">In MySQL 8 or later just use the RANK, DENSE_RANK or ROW_NUMBER functions:</a><br>套用在範例的SQL就會長這樣</p><pre><code class="SQL">SELECT     Person, Height, Weight, UpdateTimeFROM    (    SELECT *,    ROW_NUMBER() OVER (partition by Person ORDER BY Person, UpdateTime) AS num    FROM TainanParking.GridStatic    ) as aWHERE num &lt;= 1</code></pre><p>撈出來應該就會像是</p><table><thead><tr><th>Person</th><th>Height</th><th>Weight</th><th>UpdateTime</th></tr></thead><tbody><tr><td>Andy</td><td>160</td><td>58</td><td>2020-09-01</td></tr><tr><td>Bob</td><td>168</td><td>65</td><td>2020-09-01</td></tr></tbody></table><p><img src="https://media.giphy.com/media/jrutBd1N7ZhsINAPzs/giphy.gif" alt="OMG"><br>這種寫法真的是好多了<br>而且這個需求應該很常用到，趕緊筆記起來<br>終於打完了~ 下課啦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-在每個群組中取-N-筆資料-Get-1…N-Results-From-Each-Group&quot;&gt;&lt;a href=&quot;#MySQL-在每個群組中取-N-筆資料-Get-1…N-Results-From-Each-Group&quot; class=&quot;headerlin
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>Node.js + PM2 設置環境變數，更彈性地開發與部屬</title>
    <link href="https://huskylin.github.io/2020/06/18/Node-js-PM2-%E8%A8%AD%E7%BD%AE%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8%EF%BC%8C%E6%9B%B4%E5%BD%88%E6%80%A7%E5%9C%B0%E9%96%8B%E7%99%BC%E8%88%87%E9%83%A8%E5%B1%AC/"/>
    <id>https://huskylin.github.io/2020/06/18/Node-js-PM2-%E8%A8%AD%E7%BD%AE%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8%EF%BC%8C%E6%9B%B4%E5%BD%88%E6%80%A7%E5%9C%B0%E9%96%8B%E7%99%BC%E8%88%87%E9%83%A8%E5%B1%AC/</id>
    <published>2020-06-18T10:10:00.000Z</published>
    <updated>2023-02-20T12:52:00.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-PM2-設置環境變數，更彈性地開發與部屬"><a href="#Node-js-PM2-設置環境變數，更彈性地開發與部屬" class="headerlink" title="Node.js + PM2 設置環境變數，更彈性地開發與部屬"></a>Node.js + PM2 設置環境變數，更彈性地開發與部屬</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用 node.js 時一定會遇到<br><code>開發(dev)</code>與<code>生產(production)</code>，甚至更多階段的不同環境<br>可能每一種環境都有不同的設定檔案<br>例如:<br>開發階段要連線到本機的資料庫<br>生產階段要連線到另一台伺服器的資料庫<br>這時候就需要更彈性的來做設定</p><h2 id="在-Node-js-設定-config"><a href="#在-Node-js-設定-config" class="headerlink" title="在 Node.js 設定 config"></a>在 Node.js 設定 config</h2><p>可以針對不同的階段環境來設定各種連線參數<br>例如:</p><pre><code class="JavaScript">const env = process.env.NODE_ENV; // &#39;dev&#39; or &#39;prod&#39;const configs = {}configs.dev = {  db: {    host: &#39;YourHost1&#39;,    port: 3306,    user: &quot;YourUser&quot;,    password: &#39;yourPassword1&#39;,    database: &#39;YourDB1&#39;  }};configs.prod = {  db: {    host: &#39;YourHost2&#39;,    port: 3306,    user: &quot;YourUser2&quot;,    password: &#39;yourPassword2&#39;,    database: &#39;YourDB2&#39;  }}module.exports = configs[env];</code></pre><p>如此一來 Node.js 就會根據<code>環境變數</code>來 exports 不同的設定</p><h2 id="使用-PM2-來運行-Node-js-時"><a href="#使用-PM2-來運行-Node-js-時" class="headerlink" title="使用 PM2 來運行 Node.js 時"></a>使用 PM2 來運行 Node.js 時</h2><p>PM2 是一個 node 的程序管理器<br>主要功能有<code>自動重啟服務</code>, <code>叢集功能更有效的利用多核CPU</code>等等<br>網路上介紹非常多，可以參考這些連結來看介紹與用法</p><ul><li><a href="https://tn710617.github.io/zh-tw/pm2/" target="_blank" rel="noopener">pm2 - 用法大全</a> </li><li><a href="https://larrylu.blog/nodejs-pm2-cluster-455ffbd7671" target="_blank" rel="noopener">使用 pm2 啟動 Node.js cluster 以提升效能</a></li></ul><p>我主要想分享的是，當我們使用 PM2 時<br><strong>希望在<code>叢集模式(cluster)</code>下運行Node服務，又要設定<code>環境變數</code>時的作法</strong><br>一開始直覺的想法是直接都打在參數</p><ul><li><a href="https://stackoverflow.com/questions/43130494/how-to-npm-start-with-pm2-cluster-mode" target="_blank" rel="noopener">how to “npm start” with pm2 cluster mode</a></li><li><a href="https://stackoverflow.com/questions/33656947/passing-environment-variables-to-node-js-using-pm2" target="_blank" rel="noopener">Passing environment variables to node.js using pm2</a></li></ul><p>後來發現比較好的做法，是設置一個<code>PM2的參數設定檔</code><br>(後來才發現其實官方的文件就寫得很清楚了)</p><h2 id="使用-Ecosystem-File"><a href="#使用-Ecosystem-File" class="headerlink" title="使用 Ecosystem File"></a>使用 Ecosystem File</h2><p><a href="https://pm2.keymetrics.io/docs/usage/environment/" target="_blank" rel="noopener">PM2官方文件</a></p><ol><li>先產生一個<code>ecosystem.config.js</code></li><li>設置範例</li></ol><pre><code class="JavaScript">module.exports = {  apps : [{    name: &quot;app&quot;,    script: &quot;./app.js&quot;,    env: {      NODE_ENV: &quot;development&quot;,    },    env_production: {      NODE_ENV: &quot;production&quot;,    }  }]}</code></pre><ol start="3"><li>運行指令</li></ol><pre><code class="Bash">pm2 start ecosystem.config.js --env production</code></pre><p>這裡值得留意的是<br>在上面的例子中，<code>--env</code>這個參數後面接是<code>production</code>而不是<code>env_production</code><br>我原本想說應該是要輸入設定檔的 Object key<br>結果直接失敗，我還不夠難嗎?<br>差點躺在床上蓋著面被抱著自己哭出來</p><p>後來又發現其實在更下面的官方文件<br>又有說明了</p><blockquote><p>Example:</p><pre><code class="bash"># Inject what is declared in env_productionpm2 start process.json --env production# Inject what is declared in env_stagingpm2 restart process.json --env staging</code></pre></blockquote><p>( 害我不能怪官方沒寫清楚了 )<br>( 改怪他怎麼分那麼開好了 QQ )</p><h2 id="廢話時間"><a href="#廢話時間" class="headerlink" title="廢話時間"></a>廢話時間</h2><p>改造完自己的設置<br>是不是覺得自己的Node.js Server變得更進化啦<br><img src="https://media.giphy.com/media/u1k1kpDZSw5sA/giphy.gif" alt="evolution"><br><strong>進化為 Dev &amp; Production 皆可適應的雙棲動物</strong><br>獻唱一首蔡健雅的雙棲動物</p><blockquote><p>很想哭~　哭完無助~</p></blockquote><p>打完收工!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node-js-PM2-設置環境變數，更彈性地開發與部屬&quot;&gt;&lt;a href=&quot;#Node-js-PM2-設置環境變數，更彈性地開發與部屬&quot; class=&quot;headerlink&quot; title=&quot;Node.js + PM2 設置環境變數，更彈性地開發與部屬&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>在Node.JS透過ODBC連接impala完整教學(下)</title>
    <link href="https://huskylin.github.io/2020/06/17/%E5%9C%A8Node-JS%E9%80%8F%E9%81%8EODBC%E9%80%A3%E6%8E%A5Impala%E5%AE%8C%E6%95%B4%E6%95%99%E5%AD%B8-%E4%B8%8B/"/>
    <id>https://huskylin.github.io/2020/06/17/%E5%9C%A8Node-JS%E9%80%8F%E9%81%8EODBC%E9%80%A3%E6%8E%A5Impala%E5%AE%8C%E6%95%B4%E6%95%99%E5%AD%B8-%E4%B8%8B/</id>
    <published>2020-06-17T10:00:22.000Z</published>
    <updated>2023-02-20T12:52:39.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Node-JS透過ODBC連接Impala完整教學-下"><a href="#在Node-JS透過ODBC連接Impala完整教學-下" class="headerlink" title="在Node.JS透過ODBC連接Impala完整教學(下)"></a>在Node.JS透過ODBC連接Impala完整教學(下)</h1><h2 id="步驟二，在-Node-js-上連接到-Ubuntu-上的-ODBC"><a href="#步驟二，在-Node-js-上連接到-Ubuntu-上的-ODBC" class="headerlink" title="步驟二，在 Node.js 上連接到 Ubuntu 上的 ODBC"></a>步驟二，在 Node.js 上連接到 Ubuntu 上的 ODBC</h2><p>上一篇完成了<code>在 Ubuntu 上安裝 ODBC Driver</code>的部分<br>接下來就是透過 Node.js來連接啦<br><img src="https://media.giphy.com/media/oymRV1UYQWLFNM78Xe/giphy.gif" alt="letsgo"></p><h3 id="1-安裝套件"><a href="#1-安裝套件" class="headerlink" title="1. 安裝套件"></a>1. 安裝套件</h3><p>看了一下 Node.js 連接 ODBC的 相關套件<br>這套是到近期都還有有維持更新的，因此採用<br><a href="https://github.com/markdirish/node-odbc/" target="_blank" rel="noopener">node-odbc</a></p><pre><code class="Bash">npm install odbc</code></pre><h3 id="2-設定連接"><a href="#2-設定連接" class="headerlink" title="2. 設定連接"></a>2. 設定連接</h3><p>官方範例</p><pre><code class="JavaScript">const odbc = require(&#39;odbc&#39;);async function connectToDatabase() {    const connection1 = await odbc.connect(&#39;DSN=MYDSN&#39;);    // connection1 is now an open Connection    // or using a configuration object    const connectionConfig = {        connectionString: &#39;DSN=MYDSN&#39;,        connectionTimeout: 10,        loginTimeout: 10,    }    const connection2 = await odbc.connect(connectionConfig);    // connection2 is now an open Connection}connectToDatabase();</code></pre><p>這邊比較要注意的是<br><code>connectionString: &#39;DSN=MYDSN&#39;</code><br>這個<code>DSN</code>就是<code>Data Source Name</code><br>如果是按照上一篇的範例，我們是取名為<code>impalaodbc</code><br>所以會長這樣</p><pre><code class="JavaScript">const connectionConfig = {      connectionString: &#39;DSN=impalaodbc&#39;,      connectionTimeout: 10,      loginTimeout: 10,    }</code></pre><h3 id="3-執行-Query"><a href="#3-執行-Query" class="headerlink" title="3. 執行 Query"></a>3. 執行 Query</h3><p>執行 Query、Pool 可以在官方文件上查詢 API 與範例<br>這個套件的官方文件 API 寫得蠻清楚的<br><a href="https://github.com/markdirish/node-odbc/#api" target="_blank" rel="noopener">主要可以在上面看</a><br>但是值得注意的是<br><strong>Impala 的欄位名稱是不分大小寫的</strong><br><strong>Impala 的欄位名稱是不分大小寫的</strong><br><strong>Impala 的欄位名稱是不分大小寫的</strong></p><blockquote><p>Impala identifiers are always case-insensitive. That is, tables named t1 and T1 always refer to the same table, regardless of quote characters. Internally, Impala always folds all specified table and column names to lowercase. This is why the column headers in query output are always displayed in lowercase.<br><a href="https://docs.cloudera.com/documentation/enterprise/5-5-x/topics/impala_identifiers.html" target="_blank" rel="noopener">官方文件說明</a></p></blockquote><p>像我是從<code>MySQL</code>轉移過來的就會遇到問題<br>所以我寫了一個取代欄位名稱的 Function<br>第一個參數是從<code>Impala</code>撈回來的資料<br>第二個參數則是你希望取代的欄位名稱<br>例如: <code>[&#39;Id&#39;, &#39;InfoDate&#39;, &#39;ColName&#39;, &#39;Something&#39;...]</code><br>直接取代每一個物件的<code>key</code></p><pre><code class="JavaScript">function toCaseSensitiveKeys(result, newKeys) {  // make keys array to keys object  const replacements = {};  if (newKeys !== undefined) {    newKeys.forEach(key =&gt; {      replacements[key.toLowerCase()] = key;    })  }  // pair keys by replacements object  const data = result.map(row =&gt; {    const replacedItems = Object.keys(row).map(key =&gt; {      const newKey = replacements[key] || key;      return { [newKey]: row[key] };    })    const newResult = replacedItems.reduce((a, b) =&gt; Object.assign({}, a, b));    return newResult;  });  return data;}</code></pre><p>最後的 Query Function </p><pre><code class="JavaScript">const impalaQuery = (sql, values, newKeys) =&gt; {  return new Promise((resolve, reject) =&gt; {    // Create Connection Pool    const connectionConfig = {      connectionString: &#39;DSN=impalaodbc&#39;,      connectionTimeout: 10,      loginTimeout: 10,    }    odbc.connect(connectionConfig, (conError, connection) =&gt; {      if (conError) {        reject(conError);      }      connection.query(sql, values, (err, rows) =&gt; {        if (err) {          // If execute SQL faild, print SQL          connection.createStatement((error1, statement) =&gt; {            if (error1) { console.log(error1, statement); return; } // handle            statement.prepare(sql, (error2) =&gt; {              if (error2) { console.log(error2, statement); return; } // handle              statement.bind(values, (error3) =&gt; {                if (error3) { console.log(error3, statement); return; } // handle              });            });          });          reject(err);        }        else {          const idx = rows.indexOf(&#39;statement&#39;)          const values = rows.slice(0, idx).map((e, i) =&gt; {            return e          })          const data = toCaseSensitiveKeys(values, newKeys);          // print SQL          console.log(rows[&#39;statement&#39;]);          resolve(data);        }      });    });  });};</code></pre><p>主要是加入了</p><ol><li>錯誤時透過階段來偵錯</li><li>印出執行的SQL</li><li>轉換大小寫 </li></ol><p>在其他地方就可以這樣使用</p><pre><code class="JavaScript">const sql = &#39;yourSQL&#39;;const values = [SomeParms...];const keys = [SomeColNames...];impalaQuery(sql, values, keys)    .then(results =&gt; {        res.status(200).json(results);    })    .catch(err =&gt; {        console.log(err);        res.status(500).send(&#39;DB Error&#39;);    });</code></pre><p><strong>這次的<code>在Node.JS透過ODBC連接Impala</code>就大功告成啦!</strong><br>其實蠻費工的，寫這篇文時也回顧了不少苦難<br>希望可以幫助到有同樣需求的人~<br><img src="https://media.giphy.com/media/oOX5qIDkzDjeo/giphy.gif" alt="cry_laugh"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在Node-JS透過ODBC連接Impala完整教學-下&quot;&gt;&lt;a href=&quot;#在Node-JS透過ODBC連接Impala完整教學-下&quot; class=&quot;headerlink&quot; title=&quot;在Node.JS透過ODBC連接Impala完整教學(下)&quot;&gt;&lt;/a&gt;在
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>在Node.JS透過ODBC連接impala完整教學(上)</title>
    <link href="https://huskylin.github.io/2020/06/15/%E5%9C%A8Node-JS%E9%80%8F%E9%81%8EODBC%E9%80%A3%E6%8E%A5Impala%E5%AE%8C%E6%95%B4%E6%95%99%E5%AD%B8-%E4%B8%8A/"/>
    <id>https://huskylin.github.io/2020/06/15/%E5%9C%A8Node-JS%E9%80%8F%E9%81%8EODBC%E9%80%A3%E6%8E%A5Impala%E5%AE%8C%E6%95%B4%E6%95%99%E5%AD%B8-%E4%B8%8A/</id>
    <published>2020-06-15T10:00:22.000Z</published>
    <updated>2023-02-20T12:52:36.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Node-JS透過ODBC連接Impala完整教學-上"><a href="#在Node-JS透過ODBC連接Impala完整教學-上" class="headerlink" title="在Node.JS透過ODBC連接Impala完整教學(上)"></a>在Node.JS透過ODBC連接Impala完整教學(上)</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>原本專案的後端，在開發階段時採用<code>Node.js</code>連接<code>MySQL</code><br>結果後來到部屬階段時要改連接到<code>impala</code><br><strong>原本以為是小事一樁，後來採坑連連</strong><br>於是產生了本篇筆記<br><img src="https://media.giphy.com/media/JEVqknUonZJWU/giphy.gif" alt="crying"></p><h2 id="初始想法-node-impala-套件"><a href="#初始想法-node-impala-套件" class="headerlink" title="初始想法 node-impala 套件"></a>初始想法 node-impala 套件</h2><p>一開始看到 npm 裡面已經有人做好套件了<br>連接範例看起來也蠻簡潔的<br>就直接採用 <a href="https://www.npmjs.com/package/node-impala" target="_blank" rel="noopener">node-impala</a><br>測試後的確也蠻快就能夠連上並且撈取資料<br>但是!!<br>過很久之後才發現<br><strong>他的query一次最多回傳1024筆結果!</strong><br><strong>他的query一次最多回傳1024筆結果!</strong><br><strong>他的query一次最多回傳1024筆結果!</strong></p><p>看了issue後才發現<br>是因為底層使用<code>Beeswax</code>來連接，這是<code>Beeswax</code>的限制無法改變</p><blockquote><p>Beeswax limits the query result. It is not possible to increase the size by setting <em>fetch_size</em> <a href="https://github.com/ufukomer/node-impala/blob/master/src/thrift/beeswax.thrift#L129" target="_blank" rel="noopener">here</a>. Let’s use the <strong>HiveServer2</strong> #4. 🙈</p></blockquote><p><a href="https://github.com/ufukomer/node-impala/issues/11#issuecomment-274798646" target="_blank" rel="noopener">原討論串</a></p><p>煎熬了一陣子後決定直接放棄另尋他路</p><h2 id="解法-ODBC"><a href="#解法-ODBC" class="headerlink" title="解法 ODBC"></a>解法 ODBC</h2><p>後來找到的方法是在系統環境下先裝好 ODBC 來連接 Impala<br>後端 Node.js 再去連 ODBC<br>我們的作業系統環境是使用<code>Ubuntu 18.04</code><br>所以接下來就是有兩個步驟要執行</p><ol><li>在 Ubuntu 上安裝 ODBC Driver</li><li>在 Node.js 上連接到 Ubuntu 上的 ODBC</li></ol><h2 id="步驟一，在-Ubuntu-上安裝-ODBC-Driver"><a href="#步驟一，在-Ubuntu-上安裝-ODBC-Driver" class="headerlink" title="步驟一，在 Ubuntu 上安裝 ODBC Driver"></a>步驟一，在 Ubuntu 上安裝 ODBC Driver</h2><h3 id="1-下載安裝包"><a href="#1-下載安裝包" class="headerlink" title="1. 下載安裝包"></a>1. 下載安裝包</h3><p><a href="https://www.cloudera.com/downloads/connectors/impala/odbc/2-6-10.html" target="_blank" rel="noopener">cloudera下載連結</a><br><a href="https://docs.cloudera.com/documentation/other/connectors/impala-odbc/latest/Cloudera-ODBC-Driver-for-Impala-Install-Guide.pdf#%5B%7B%22num%22%3A218%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C78%2C729.75%2C0%5D" target="_blank" rel="noopener">Cloudera ODBC Driver for Impala 官方文件說明</a></p><h3 id="2-設定環境變數"><a href="#2-設定環境變數" class="headerlink" title="2. 設定環境變數"></a>2. 設定環境變數</h3><pre><code class="Bash">export LD_LIBRARY_PATH=/usr/local/lib:/opt/cloudera/impalaodbc/lib/64export CLOUDERAIMPALAINI=/opt/cloudera/impalaodbc/lib/64/cloudera.impalaodbc.iniexport LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libodbcinst.soexport ODBCINI=/etc/odbc.iniexport ODBCSYSINI=/etc</code></pre><h3 id="3-設定-ODBC-driver-的參數檔"><a href="#3-設定-ODBC-driver-的參數檔" class="headerlink" title="3. 設定 ODBC driver 的參數檔"></a>3. 設定 ODBC driver 的參數檔</h3><p>大致上長這樣<br>比較需要注意的地方是</p><ol><li><code>[impalaodbc]</code> 這是你自己要取的 Data Source Name</li><li><code>PORT</code>要注意一下是21050還是21000</li><li>`Drive‵路徑</li><li>帳號密碼、DB位置等等<br>其他都是預設值而已，自行參考變化即可</li></ol><pre><code class="Bash">[impalaodbc]# Description: DSN Description. This key is not necessary and is only to give a description of the data# source.Description=Cloudera ODBC Driver for Impala (64-bit) DSN# Driver: The location where the ODBC driver is installed to.Driver=/opt/cloudera/impalaodbc/lib/64/libclouderaimpalaodbc64.so# The DriverUnicodeEncoding setting is only used for SimbaDM When set to 1, SimbaDM runs in UTF-16 mode. When#set to 2, SimbaDM runs in UTF-8 mode. DriverUnicodeEncoding=2# Values for HOST, PORT, KrbFQDN, and KrbServiceName should be set here. They can also be specified on the# connection string.HOST=Impala Server的IP位置PORT=21050Database=DB名稱# The authentication mechanism. 0 - no authentication. 1 - Kerberos authentication 2 - Username# authentication. 3 - Username/password authentication. 4 - Username/password authentication with SSL.AuthMech=0# Kerberos related settings.KrbFQDN=KrbRealm=KrbServiceName=# Username/password authentication with SSL settings.UID=DB帳號PWD=DB密碼CAIssuedCertNamesMismatch=1TrustedCerts=/opt/cloudera/impalaodbc/lib/64/cacerts.pem# Specify the proxy user ID to use. DelegationUID=# General settingsTSaslTransportBufSize=1000RowsFetchedPerBlock=1000SocketTimeout=0</code></pre><h3 id="4-安裝-unixODBC"><a href="#4-安裝-unixODBC" class="headerlink" title="4. 安裝 unixODBC"></a>4. 安裝 unixODBC</h3><pre><code class="Bash">sudo apt-get install unixODBC unixODBC-dev</code></pre><h3 id="5-測試"><a href="#5-測試" class="headerlink" title="5. 測試"></a>5. 測試</h3><ol><li>查看你的ODBC設定<pre><code class="Bash"> odbcinst -q -s</code></pre> 如果成功的話應該會顯示你的 Data Source Name</li><li>測試連線<pre><code class="Bash"> isql -v impalaodbc</code></pre> 如果成功的話應該會顯示你的連線後介面</li></ol><p><img src="https://i.imgur.com/gzoUbOp.png" alt=""></p><p>到這部分完成了在 Ubuntu 上安裝 ODBC Driver<br><strong>\ 恭喜恭喜 / \ 灑花灑花/</strong><br><img src="https://media.giphy.com/media/MhHXeM4SpKrpC/giphy.gif" alt="congrats"><br>喘口氣，下一篇再來講 步驟二 Node.js 的部分~</p><h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ol><li><a href="http://hadoop4beginner.blogspot.com/2015/05/installing-impala-odbc-driver-in-ubuntu.html" target="_blank" rel="noopener">Installing Impala ODBC Driver in Ubuntu 64 bit </a></li><li><a href="https://blog.csdn.net/yangzhaohui168/article/details/38800803" target="_blank" rel="noopener">Impala ODBC 安装笔记</a></li><li><a href="https://blog.csdn.net/ggz631047367/article/details/50703990" target="_blank" rel="noopener">ubuntu14.04配置impala的odbc连接</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在Node-JS透過ODBC連接Impala完整教學-上&quot;&gt;&lt;a href=&quot;#在Node-JS透過ODBC連接Impala完整教學-上&quot; class=&quot;headerlink&quot; title=&quot;在Node.JS透過ODBC連接Impala完整教學(上)&quot;&gt;&lt;/a&gt;在
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Server 18.04 離線狀態下安裝 MySQL</title>
    <link href="https://huskylin.github.io/2019/07/16/Ubuntu-Server-18-04-%E9%9B%A2%E7%B7%9A%E7%8B%80%E6%85%8B%E4%B8%8B%E5%AE%89%E8%A3%9D-MySQL/"/>
    <id>https://huskylin.github.io/2019/07/16/Ubuntu-Server-18-04-%E9%9B%A2%E7%B7%9A%E7%8B%80%E6%85%8B%E4%B8%8B%E5%AE%89%E8%A3%9D-MySQL/</id>
    <published>2019-07-16T03:35:15.000Z</published>
    <updated>2023-02-20T12:52:20.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Ubuntu-Server-18-04-離線狀態下安裝-MySQL-Install-MySQL-on-Ubuntu-While-Offline"><a href="#在-Ubuntu-Server-18-04-離線狀態下安裝-MySQL-Install-MySQL-on-Ubuntu-While-Offline" class="headerlink" title="在 Ubuntu Server 18.04 離線狀態下安裝 MySQL (Install MySQL on Ubuntu While Offline)"></a>在 Ubuntu Server 18.04 離線狀態下安裝 MySQL (Install MySQL on Ubuntu While Offline)</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近一個專案遇到的情況，基於資安政策考量，規定機器不能連外部網路<br>這樣就不能直接使用<code>sudo apt-get install mysql-serve</code>來安裝<br>過程蠻不方便的，記錄一下給遇到同樣處境的人。<br>作法主要參考了這篇文章: <a href="https://www.cnblogs.com/JasonTech0713/p/6690949.html" target="_blank" rel="noopener">ubuntu16.04 安装离线 mysql5.7.17</a><br>但是<strong>MySQL 8.0 版本與以前的版本安裝步驟略有不同</strong>，會在以下內容中提到</p><hr><h2 id="準備安裝包"><a href="#準備安裝包" class="headerlink" title="準備安裝包"></a>準備安裝包</h2><h3 id="1-下載對應的-MySQL-安裝包"><a href="#1-下載對應的-MySQL-安裝包" class="headerlink" title="1. 下載對應的 MySQL 安裝包"></a>1. 下載對應的 MySQL 安裝包</h3><p>本文以<code>Ubuntu Linux 18.04 (x86, 64-bit), DEB Bundle</code>為例<br><img src="https://i.imgur.com/ZJVBRTi.png" alt="MySQL官網下載"></p><h3 id="2-準備-USB"><a href="#2-準備-USB" class="headerlink" title="2. 準備 USB"></a>2. 準備 USB</h3><p>檢查一下裡面包含這些檔案<br>把<code>mysql-server_8.0.16–2ubuntu18.04_amd64.deb-bundle.tar</code><br>放置到 USB 隨身碟裝置中<br><img src="https://i.imgur.com/5dEPbNl.png" alt="mysql-server-deb-bundle"></p><blockquote><p>註記: 這邊 USB 要先在 Ubuntu 環境中測試看看能不能用，有些需要重新格式化</p></blockquote><hr><h2 id="掛載-USB-隨身碟"><a href="#掛載-USB-隨身碟" class="headerlink" title="掛載 USB 隨身碟"></a>掛載 USB 隨身碟</h2><h3 id="1-先查-USB-隨身碟是被系統辨識成那個裝置"><a href="#1-先查-USB-隨身碟是被系統辨識成那個裝置" class="headerlink" title="1. 先查 USB 隨身碟是被系統辨識成那個裝置"></a>1. 先查 USB 隨身碟是被系統辨識成那個裝置</h3><p><code>fdisk -l</code><br>sda 很可能是硬碟,往下查容量可以找到隨身碟的編號<br>我們假設為 sdb<br><img src="https://i.imgur.com/fmLmCIO.png" alt=""></p><h3 id="2-建立-USB-隨身碟的掛載點："><a href="#2-建立-USB-隨身碟的掛載點：" class="headerlink" title="2. 建立 USB 隨身碟的掛載點："></a>2. 建立 USB 隨身碟的掛載點：</h3><p><code>mkdir /mnt/usb</code></p><h3 id="3-掛載-USB-隨身碟"><a href="#3-掛載-USB-隨身碟" class="headerlink" title="3. 掛載 USB 隨身碟"></a>3. 掛載 USB 隨身碟</h3><p><code>mount -v -t auto /dev/sdb /mnt/usb</code></p><blockquote><p>-v 顯示資訊<br>-t auto 讓系統自動分辯檔案系統</p></blockquote><h3 id="4-到-mnt-usb-可看到-usb-的內容"><a href="#4-到-mnt-usb-可看到-usb-的內容" class="headerlink" title="4. 到 /mnt/usb 可看到 usb 的內容"></a>4. 到 /mnt/usb 可看到 usb 的內容</h3><p>解壓縮後檢視一下檔案<br><img src="https://i.imgur.com/x2u701t.png" alt="USB掛載內容"></p><blockquote><p>註記: 檔名多一個(1)的部份是我有重新下載過<br>第一次下載時不知道是不是檔案有毀損，出現異常錯誤<br>如果有遇到也可以試試看重新下載</p></blockquote><hr><h2 id="開始安裝"><a href="#開始安裝" class="headerlink" title="開始安裝"></a>開始安裝</h2><h3 id="1-下載依賴的安裝包"><a href="#1-下載依賴的安裝包" class="headerlink" title="1. 下載依賴的安裝包"></a>1. 下載依賴的安裝包</h3><p>根據參考文章，還需要兩個額外依賴包，可以在這邊下載<br><a href="https://pkgs.org/download/libaio1" target="_blank" rel="noopener">https://pkgs.org/download/libaio1</a><br><a href="https://pkgs.org/download/libmecab2" target="_blank" rel="noopener">https://pkgs.org/download/libmecab2</a></p><h3 id="2-安裝-MySQL"><a href="#2-安裝-MySQL" class="headerlink" title="2. 安裝 MySQL"></a>2. 安裝 MySQL</h3><ol><li><code>sudo dpkg -i mysql-common_8.0.16–2ubuntu18.04_amd64.deb</code></li><li><code>sudo dpkg-preconfigure mysql-community-server_8.0.16–2ubuntu18.04_amd64.deb</code><br><strong>(這步驟會跳出安裝畫面，並且需要輸入 root 密碼)</strong></li><li><code>sudo dpkg -i libmysqlclient21_8.0.16–2ubuntu18.04_amd64.deb</code></li><li><code>sudo dpkg -i libmysqlclient-dev_8.0.16–2ubuntu18.04_amd64.deb</code></li><li>參考文章中這一步是安裝<code>libmysqld-dev_5.7.16–1ubuntu16.04_amd64.deb</code><br>但是根據官方版本資訊，8.0 版本已經不需要這個檔案了，所以不需要做這個步驟<br><img src="https://i.imgur.com/Czreha1.png" alt="MySQL 8.0官方資訊"></li><li>參考文章中的這步驟是安裝<code>mysql-community-client_8.0.16–2ubuntu18.04_amd64.deb</code><br>不過如果直接安裝會跳出錯誤，顯示缺少依賴，所以在這 8.0 中需要先安裝<br><code>mysql-community-client-core_8.0.16–2ubuntu18.04_amd64.deb</code><br>所以執行<br><code>sudo dpkg -i mysql-community-client-core_8.0.16–2ubuntu18.04_amd64.deb</code></li><li><code>sudo dpkg -i mysql-community-client_8.0.16–2ubuntu18.04_amd64.deb</code></li><li><code>sudo dpkg -i mysql-client_8.0.16–2ubuntu18.04_amd64.deb</code></li><li><code>sudo dpkg -i mysql-common_8.0.16–2ubuntu18.04_amd64.deb</code></li><li>參考文章中的這步驟是安裝<code>mysql-community-server_8.0.16–2ubuntu18.04_amd64.de</code><br>不過如果直接安裝會跳出錯誤，顯示缺少依賴，所以在這 8.0 中需要先安裝<br><code>mysql-community-server-core_8.0.16–2ubuntu18.04_amd64.deb</code><br>所以執行<br><code>sudo dpkg -i mysql-community-server-core_8.0.16–2ubuntu18.04_amd64.deb</code></li><li><code>sudo dpkg -i mysql-community-server_8.0.16–2ubuntu18.04_amd64.deb</code></li><li><code>sudo dpkg -i mysql-server_8.0.16–2ubuntu18.04_amd64.deb</code><br><strong>打完這一大坨指令後，就大功告成啦!</strong><br>最後可以去 MySQL 裡面試一下指令，確認安裝結果<br><code>mysql -u root -p</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在-Ubuntu-Server-18-04-離線狀態下安裝-MySQL-Install-MySQL-on-Ubuntu-While-Offline&quot;&gt;&lt;a href=&quot;#在-Ubuntu-Server-18-04-離線狀態下安裝-MySQL-Install-MyS
      
    
    </summary>
    
    
    
      <category term="Back-End" scheme="https://huskylin.github.io/tags/Back-End/"/>
    
  </entry>
  
  <entry>
    <title>Leaflet讀取GeoJSON檔</title>
    <link href="https://huskylin.github.io/2018/10/07/Leaflet%E8%AE%80%E5%8F%96GeoJSON%E6%AA%94/"/>
    <id>https://huskylin.github.io/2018/10/07/Leaflet%E8%AE%80%E5%8F%96GeoJSON%E6%AA%94/</id>
    <published>2018-10-07T10:00:22.000Z</published>
    <updated>2023-02-20T12:51:40.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leaflet-讀取-GeoJSON-檔"><a href="#Leaflet-讀取-GeoJSON-檔" class="headerlink" title="Leaflet 讀取 GeoJSON 檔"></a>Leaflet 讀取 GeoJSON 檔</h1><p>透過<br>在地圖上把台灣縣市地區框選起來<br>並且點擊後會有 popup 提示該地區的縣市名稱<br>練習 Leaflet 的一些操作</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>先照著官網教學<br>引入相關文件<br>把初始地圖建出來<br><a href="https://leafletjs.com/examples/quick-start/" target="_blank" rel="noopener">https://leafletjs.com/examples/quick-start/</a></p><pre><code class="JavaScript">//  建立 Leaflet 地圖var map = L.map(&quot;mapid&quot;);//  設定經緯度座標map.setView(new L.LatLng(25, 121.74739), 13);//  設定圖資來源var osmUrl = &quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;;var osm = new L.TileLayer(osmUrl, { minZoom: 3, maxZoom: 16 });map.addLayer(osm);</code></pre><p><img src="https://i.imgur.com/e8jdeNm.png" alt=""></p><h2 id="讀入-GeoJSON-檔"><a href="#讀入-GeoJSON-檔" class="headerlink" title="讀入 GeoJSON 檔"></a>讀入 GeoJSON 檔</h2><p>根據<a href="https://noob.tw/openstreetmap/" target="_blank" rel="noopener">Web 視覺化(四)：建立 OpenStreetMap 地圖</a>提到</p><blockquote><p>Leaflet 無法直接讀取 GeoJSON 檔案，必須先透過 Ajax 等方式下載下來才行。這邊將使用 jQuery 做例子</p></blockquote><pre><code class="JavaScript">$.getJSON(&quot;YOURFILE.json&quot;, function (r) {  L.geoJSON(r, { color: &quot;#333&quot; }).addTo(map);});</code></pre><p>這樣就可以讀取 geoJSON</p><h2 id="替區塊著色"><a href="#替區塊著色" class="headerlink" title="替區塊著色"></a>替區塊著色</h2><p>希望讓不同區塊有不同顏色<br>這邊試做一個，把新北市著色</p><pre><code class="JavaScript">$.getJSON(&quot;taiwan.json&quot;, function (r) {  L.geoJSON(r, {    //  樣式可透過function操作    style: function (feature) {      if (feature.properties.COUNTYID == 65) {        console.log(feature.properties.NAME_2014);        return { color: &quot;#4f45c0&quot; };      } else {        return { color: &quot;#444444&quot; };      }    },    onEachFeature: onEachFeature,  }).addTo(map);});</code></pre><p><img src="https://i.imgur.com/VWeuBWb.png" alt=""></p><h2 id="點擊區塊彈出提示"><a href="#點擊區塊彈出提示" class="headerlink" title="點擊區塊彈出提示"></a>點擊區塊彈出提示</h2><p>這邊希望該縣市區塊後會彈出提示的視窗<br>這邊的 NAME_2014 是該資料中的 properties 有這個 NAME_2014 屬性<br>裡面是該縣市地區的名字</p><pre><code class="JavaScript">//  綁定每個feature做Popup，可以視資料有什麼properties來決定function onEachFeature(feature, layer) {  if (feature.properties &amp;&amp; feature.properties.NAME_2014) {    layer.bindPopup(feature.properties.NAME_2014);  }}</code></pre><p><img src="https://i.imgur.com/OIT3Ta1.png" alt=""></p><p>另外再加入官網範例中<br>點地圖的其他位置後<br>顯示座標位置</p><pre><code class="JavaScript">var popup = L.popup();function onMapClick(e) {  popup    .setLatLng(e.latlng)    .setContent(&quot;You clicked the map at &quot; + e.latlng.toString())    .openOn(map);}map.on(&quot;click&quot;, onMapClick);</code></pre><p><img src="https://i.imgur.com/HT8HW9s.png" alt=""></p><h2 id="其他延伸"><a href="#其他延伸" class="headerlink" title="其他延伸"></a>其他延伸</h2><p>如果想要自己繪製<br>可以使用<a href="http://geojson.io" target="_blank" rel="noopener">geojson.io</a>的服務</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://sheethub.com/ronnywang/%E4%B8%AD%E8%8F%AF%E6%B0%91%E5%9C%8B%E7%B8%A3%E5%B8%82" target="_blank" rel="noopener">中華民國縣市的 geojson 檔</a><br><a href="https://leafletjs.com/examples/geojson/" target="_blank" rel="noopener">Leaflet 對 GeoJSON 的官方說明</a><br><a href="https://www.youtube.com/watch?v=fDfkjx-VhLI&list=PL4TUtpN0YlFK3YRuJIS0KIxalBGJ4eqIR" target="_blank" rel="noopener">老外教學影片</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leaflet-讀取-GeoJSON-檔&quot;&gt;&lt;a href=&quot;#Leaflet-讀取-GeoJSON-檔&quot; class=&quot;headerlink&quot; title=&quot;Leaflet 讀取 GeoJSON 檔&quot;&gt;&lt;/a&gt;Leaflet 讀取 GeoJSON 檔&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>CSS放大圖片會爆框</title>
    <link href="https://huskylin.github.io/2018/09/01/CSS%E6%94%BE%E5%A4%A7%E5%9C%96%E7%89%87%E6%9C%83%E7%88%86%E6%A1%86/"/>
    <id>https://huskylin.github.io/2018/09/01/CSS%E6%94%BE%E5%A4%A7%E5%9C%96%E7%89%87%E6%9C%83%E7%88%86%E6%A1%86/</id>
    <published>2018-09-01T10:08:02.000Z</published>
    <updated>2023-02-20T12:51:35.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初步想法"><a href="#初步想法" class="headerlink" title="初步想法"></a>初步想法</h2><p>想要實作一個滑鼠放上去時會放大圖片簡單的效果<br>使用到的技巧</p><ol><li><code>:hover Selectors(選擇器)</code><br>用來選擇滑鼠指標經過在上面時的元素</li><li><code>transform: scale()</code><br>transform 屬性裡，用來縮放元素大小</li></ol><p>這兩個加起來就可以做出上述的效果<br>不過被選擇到放大後的圖片會爆出框框<br>這時候就需要加上<br><code>overflow: hidden</code><br>當超出邊界範圍時，將多餘的部分隱藏起來不顯示</p><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>原本以為到這邊就可以成功將效果呈現<br>但是卻發現會因為 padding 的間距<br>讓圖片放大的範圍有了”亂長大的空間”</p><h2 id="解決"><a href="#解決" class="headerlink" title="解決"></a>解決</h2><p>後來在圖片外面多包一個 div<br>並將 overflow: hidden 寫在裡面<br>文字與圖片間的 padding 就不會給圖片亂長大的空間了</p><pre><code class="CSS">.col-grid {  max-width: 450px;  overflow: hidden;  img {    max-width: 450px;    &amp;:hover {      transform: scale(1.1);      transition: 0.5s;    }  }}</code></pre><h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>左邊為目標效果，右邊是有非預期爆框的效果<br><img src="https://i.imgur.com/Bt5K9qX.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;初步想法&quot;&gt;&lt;a href=&quot;#初步想法&quot; class=&quot;headerlink&quot; title=&quot;初步想法&quot;&gt;&lt;/a&gt;初步想法&lt;/h2&gt;&lt;p&gt;想要實作一個滑鼠放上去時會放大圖片簡單的效果&lt;br&gt;使用到的技巧&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;:hover Sel
      
    
    </summary>
    
    
    
      <category term="Front-End" scheme="https://huskylin.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>用Python打造FB抽獎機，將回覆留言也列入參抽獎單</title>
    <link href="https://huskylin.github.io/2018/05/13/%E7%94%A8Python%E6%89%93%E9%80%A0FB%E6%8A%BD%E7%8D%8E%E6%A9%9F%EF%BC%8C%E5%B0%87%E5%9B%9E%E8%A6%86%E7%95%99%E8%A8%80%E4%B9%9F%E5%88%97%E5%85%A5%E5%8F%83%E6%8A%BD%E7%8D%8E%E5%96%AE/"/>
    <id>https://huskylin.github.io/2018/05/13/%E7%94%A8Python%E6%89%93%E9%80%A0FB%E6%8A%BD%E7%8D%8E%E6%A9%9F%EF%BC%8C%E5%B0%87%E5%9B%9E%E8%A6%86%E7%95%99%E8%A8%80%E4%B9%9F%E5%88%97%E5%85%A5%E5%8F%83%E6%8A%BD%E7%8D%8E%E5%96%AE/</id>
    <published>2018-05-13T10:11:47.000Z</published>
    <updated>2020-06-14T11:23:50.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="動機"><a href="#動機" class="headerlink" title="動機"></a>動機</h2><p>最近在臉書上參加活動需要朋友們按讚<br>我就辦了個抽獎讓大家參與<br>搜尋一下線上工具<br>搜尋結果前幾個似乎都無法免費支援<code>個人頁面的抽獎</code></p><h2 id="影片教學"><a href="#影片教學" class="headerlink" title="影片教學"></a>影片教學</h2><p>剛好之前看到<a href="https://www.facebook.com/pycone2016/" target="_blank" rel="noopener">Pycone 松果城市</a>有相關的教學影片<br>看上去不會太複雜，就照著實作一次了</p><p>前就如影片所示</p><iframe src="https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Fpycone2016%2Fvideos%2F1848676842125769%2F&show_text=0&width=560" width="560" height="315" style="border:none;overflow:hidden" scrolling="no" frameborder="0" allowTransparency="true" allowFullScreen="true"></iframe><ol><li>取得 Post 的 ID</li><li>Facebook Graph API</li><li>取得 Token (存取權杖)</li><li>拿到資料</li></ol><p>不過做到中間發現<br><img src="https://i.imgur.com/vWJcVqx.jpg" alt="FaceBook_API_JSON"></p><ol><li>這個教學也是做給<code>粉絲團</code>使用的</li><li>我希望讓留言中回覆的人也加入名單</li></ol><p>所以需要修改一下</p><hr><h2 id="取得留言的回覆"><a href="#取得留言的回覆" class="headerlink" title="取得留言的回覆"></a>取得留言的回覆</h2><p>由於 Facebook 的巢狀留言結構<br>每個留言也都有各自獨立的 ID<br>要一一抓取有點麻煩<br>這邊直接在語法的地方使用</p><p><code>filter=stream</code></p><p>讓它變成資料流，就會全部展開來了</p><p>另外如果留言數太多的話<br>還要加上 limit<br>否則有些會顯示不出來<br>想要全部顯，就給一個超過總留言數的數量即可</p><p><code>limit=1000</code></p><p>最後的語法為</p><p><code>&lt;Your_Post_ID&gt;/comments?filter=stream&amp;limit=1000</code></p><p>最後取得資料後再利用 SET 去除重複名單，亂數排序後印出<br>就可以完成了</p><p><a href="https://github.com/huskylin/FB-lottery" target="_blank" rel="noopener">完整的程式碼</a><br>短短幾行就可以完成了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;動機&quot;&gt;&lt;a href=&quot;#動機&quot; class=&quot;headerlink&quot; title=&quot;動機&quot;&gt;&lt;/a&gt;動機&lt;/h2&gt;&lt;p&gt;最近在臉書上參加活動需要朋友們按讚&lt;br&gt;我就辦了個抽獎讓大家參與&lt;br&gt;搜尋一下線上工具&lt;br&gt;搜尋結果前幾個似乎都無法免費支援&lt;code
      
    
    </summary>
    
    
    
      <category term="Python" scheme="https://huskylin.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
